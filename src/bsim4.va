// This code is derived from BSIM4. See LICENSE.md for license details.
// To the extent copyrightable, modifications and translation to Verilog-A are:
//
// (C) 2021 Julia Computing Inc. All rights reserved.

`define PHYSICAL_CONSTANTS_NGSPICE 1
`include "constants.vams"
`include "disciplines.vams"

// ngspice noisedefs.h

`define N_MINLOG          1e-38       /* the smallest number we can take the log of */
`define N_MINGAIN         1e-20       /* the smallest input-output gain we can tolerate */
                       /*    (to calculate input-referred noise we divide */
                       /*     the output noise by the gain) */
`define N_INTFTHRESH   1e-10       /* the largest slope (of a log-log noise spectral */
                       /*    density vs. freq plot) at which the noise */
                       /*    spectum is still considered flat. (no need for */
                       /*    log curve fitting) */
`define N_INTUSELOG      1e-10       /* decides which expression to use for the integral of */
                       /*    x**k.  If k is -1, then we must use a 'ln' form. */
                       /*    Otherwise, we use a 'power' form.  This */
                       /*    parameter is the region around (k=) -1 for which */
                       /*    use the 'ln' form. */

`define MAX_EXPL 2.688117142e+43
`define MIN_EXPL 3.720075976e-44
`define EXPL_THRESHOLD 100.0

`define MAX_EXP 5.834617425e14
`define MIN_EXP 1.713908431e-15
`define EXP_THRESHOLD 34.0

`define MM             3  /* smooth coeff */

`define ntype          1
`define ptype         -1
`define GMIN        $simparam("gmin",1e-12)
`define SIMPARSCAL  $simparam("scale",1.0)
`define SCALINGFACTOR 1e-9

// IOP( )		Input/output parameter
// IOPP( )	IO parameter which the principle value of a device (used
// 		for naming output variables in sensetivity)
// IOPA( )	IO parameter significant for time-varying (non-dc) analyses
// IOPAP( )	Principle value is significant for time-varying analyses
// IOPAA( )	IO parameter significant for ac analyses only
// IOPAAP( )	IO parameter principle value for ac analyses only
// IOPN( )	IO parameter significant for noise analyses only
// IOPR( )	Redundant IO parameter name (e.g. "vto" vs. "vt0")
// IOPX( )	IO parameter which is not used by sensetivity in any case
//  IOPQ( )	This (Q) parameter must be non-zero for sensetivity of
// 		following Z parameter (model params done first)
// IOPZ( )	Prev. 'Q' parameter must be non-zero for sensetivity
// IOPQO( )	Like Q, but or-ed with previous Q value
// ....U( )	uninteresting for default "show" command output
//

// Constants from bsim4 C code
`define Kb 1.3806226e-23
`define KboQ 8.617087e-5
`define EPS0 8.85418e-12
`define EPSSI 1.03594e-10
`define Charge_q 1.60219e-19
`define DELTA_1 0.02
`define DELTA_2 0.02
`define DELTA_3 0.02
`define DELTA_4 0.02
`define DELTA 1.0E-9
`define MM  3 /* smooth coeff */

// Constants from SPICE
`define REFTEMP 300.15 // (K)
`define CONSTvt0 (`P_K * `REFTEMP / `P_Q)

module bsim4(d, g, s, b);

    //--------------------------
    //   node | b4ld.c
    // ----------------
    //      d | BSIM4dNode
    //      g | BSIM4gNodeExt
    //      s | BSIM4sNode
    //      b | BSIM4bNode
    //     di | BSIM4dNodePrime
    //     si | BSIM4sNodePrime
    //     gi | BSIM4gNodePrime
    //     bi | BSIM4bNodePrime
    //     gm | BSIM4gNodeMid
    //     db | BSIM4dbNode
    //     sb | BSIM4sbNode
    //      q | BSIM4qNode
    //--------------------------

    inout d, g, s, b;
    electrical d, g, s, b;
    electrical di, gi, si, bi, gm, db, sb, q;

    // *** Start Parameters ***
    // N.B. Descriptions taken from the technical PDF

    // Basic MOSFET parameters
    (*units="", desc="-1: PMOS; 1: NMOS"*)
    parameter integer TYPE=`ntype from[`ptype:`ntype] ;
    (*units="m", type="instance", desc="Device Length"*)
    parameter real L=5.0e-6 from[0.0:1.0) ;
    (*units="m", type="instance", desc="Device Width"*)
    parameter real W=5.0e-6 from[0.0:1.0) ;

    // Parameters missing from manual
    (*units="m", type="instance", desc="Drain Perimeter"*)
    parameter real PD=0.0 from[0.0:inf) ;
    (*units="m", type="instance", desc="Source Perimeter"*)
    parameter real PS=0.0 from[0.0:inf) ;
    (*units="m²", type="instance", desc="Drain Area"*)
    parameter real AD=0.0 from[0.0:inf) ;
    (*units="m²", type="instance", desc="Source Area"*)
    parameter real AS=0.0 from[0.0:inf) ;
    (*units="", desc="GIDL clamp"*)
    parameter real GIDLCLAMP=-1e-5 from[-inf:0.0) ;

    (*units="√(Fs²/g)m⁻¹", desc="Parameter for Igs,d"*)
    parameter real AIGSD=TYPE == `ntype ? 1.36e-2 : 9.8e-3;
    parameter real LAIGSD = 0.0;
    parameter real WAIGSD = 0.0;
    parameter real PAIGSD = 0.0;
    (*units="√(Fs²/g)m⁻¹V⁻¹", desc="Parameter for Igs,d"*)
    parameter real BIGSD=TYPE == `ntype ? 1.71e-3 : 7.59e-4;
    parameter real LBIGSD = 0.0;
    parameter real WBIGSD = 0.0;
    parameter real PBIGSD = 0.0;
    (*units="V⁻¹", desc="Parameter for Igs,d"*)
    parameter real CIGSD=TYPE == `ntype ? 0.075 : 0.03;
    parameter real LCIGSD = 0.0;
    parameter real WCIGSD = 0.0;
    parameter real PCIGSD = 0.0;

    (*units="", desc="noise clamping limit parameter"*)
    parameter real IDOVVDSC=1e-9 from[0.0:inf) ;

    (*units="", desc="BSIM Version (represented as real)"*)
    parameter real VERSION=4.80 from[4.00:5.00) ;

    (*units="", desc="New Material Mod backward compatibility selector"*)
    parameter integer MTRLCOMPATMOD=0 from[0:1] ;

    (*units="", desc="Work function of gate"*)
    parameter real PHIG=4.05;

    // BSIM 4.8.1 Model Selectors/Controller
    (*units="", desc="Binning unit selector"*)
    parameter integer BINUNIT=1 from[0:1] ;
    (*units="", desc="Switch for parameter value check"*)
    parameter integer PARAMCHK=1 from[0:1] ;
    (*units="", desc="Mobility model selector"*)
    parameter integer MOBMOD=0 from[0:1] ;
    (*units="", desc="New material model selector"*)
    parameter integer MTRLMOD=0 from[0:1] ;
    (*units="", desc="Bias-dependent source/drain resistance model selector"*)
    parameter integer RDSMOD=0 from[0:1] ;
    (*units="", desc="Gate-to-channel tunneling current model selector"*)
    parameter integer IGCMOD=0 from[0:1] ;
    (*units="", desc="Gate-to-substrate tunneling current model selector"*)
    parameter integer IGBMOD=0 from[0:1] ;
    (*units="", desc="Threshold voltage for C-Vmodel selector"*)
    parameter integer CVCHARGEMOD=0 from[0:1] ;
    (*units="", desc="Capacitance model selector"*)
    parameter integer CAPMOD=2 from[0:2] ;
    (*units="", type="both", desc="Gate resistance model selector"*)
    parameter integer RGATEMOD=0 from[0:3] ;
    (*units="", type="both", desc="Substrate resistance network model selector"*)
    parameter integer RBODYMOD=0 from[0:2] ;
    (*units="", type="both", desc="Transient NQS model selector"*)
    parameter integer TRNQSMOD=0 from[0:1] ;
    (*units="", type="both", desc="AC small-signal NQS model selector"*)
    parameter integer ACNQSMOD=0 from[0:1] ;
    (*units="", desc="Flicker noise model selector"*)
    parameter integer FNOIMOD=1 from[0:1] ;
    (*units="", desc="Thermal noise model selector"*)
    parameter integer TNOIMOD=0 from[0:1] ;
    (*units="", desc="Source/drain junction diode IV model selector"*)
    parameter integer DIOMOD=0 from[0:2] ;
    (*units="", desc="Temperature mode selector"*)
    parameter integer TEMPMOD=0 from[0:1] ;
    (*units="", desc="Whether PS/PD (when given) includes the gate-edge perimeter"*)
    parameter integer PERMOD=1 from[0:1] ;
    (*units="", type="both", desc="Geometry-dependent parasitics model selector - specifying how the end S/D diffusions are connected"*)
    parameter integer GEOMOD=0 from[0:1] ;
    (*units="", type="both", desc="Source/drain diffusion resistance and contact model selector - specifying the end S/D contact type: point, wide or merged, and how S/D parasitics resistance is computed"*)
    parameter integer RGEOMOD=0 from[0:1] ;
    (*units="", desc="Flag for WPE model (WPEMOD=1 to activate this model)"*)
    parameter integer WPEMOD=0 from[0:1] ;
    (*units="", desc="GIDL current model selector"*)
    parameter integer GIDLMOD=0 from[0:1] ;

    // Process Parameters
    (*units="", desc="Relative dielectric constant of the gate dielectric"*)
    parameter real EPSROX=3.9 from[1.0:inf) ;
    (*units="m", desc="Electrical gate equivalent oxide thickness"*)
    parameter real TOXE=3e-9 from[1e-10:inf) ;
    (*units="m", desc="Equivalent SiO₂ thickness"*)
    parameter real EOT=1.5e-9 from[0.0:inf) ;
    (*units="m", desc="Physical gate equivalent oxide thickness"*)
    parameter real TOXP=TOXE from[1e-10:inf) ;
    (*units="m", desc="Tox at which parameters are extracted"*)
    parameter real TOXM=TOXE from[1e-10:inf) ;
    (*units="m", desc="Defined as (TOXE-TOXP)"*)
    parameter real DTOX=TOXE-TOXP;
    (*units="m", desc="S/D junction depth"*)
    parameter real XJ=1.5e-7;
    parameter real LXJ = 0.0;
    parameter real WXJ = 0.0;
    parameter real PXJ = 0.0;
    // 5.753e-12 * sqrt(NDEP) / coxe - handled below
    (*units="", desc="Body-effect coefficient near the surface"*)
    parameter real GAMMA1=0.0 from[0:inf) ;
    parameter real LGAMMA1 = 0.0;
    parameter real WGAMMA1 = 0.0;
    parameter real PGAMMA1 = 0.0;
    // 5.753e-12 * sqrt(NDEP) / coxe - handled below
    (*units="", desc="Body-effect coefficient near the bulk"*)
    parameter real GAMMA2=0.0 from[0:inf) ;
    parameter real LGAMMA2 = 0.0;
    parameter real WGAMMA2 = 0.0;
    parameter real PGAMMA2 = 0.0;
    (*units="cm⁻³", desc="Channel doping concentration at depletion edge for zero body bias"*)
    parameter real NDEP=1e17 from[0:inf) ;
    parameter real LNDEP = 0.0;
    parameter real WNDEP = 0.0;
    parameter real PNDEP = 0.0;
    (*units="cm⁻³", desc="Substrate doping concentration"*)
    parameter real NSUB=6e16 from[0:inf) ;
    parameter real LNSUB = 0.0;
    parameter real WNSUB = 0.0;
    parameter real PNSUB = 0.0;
    (*units="cm⁻³", desc="Poly Si gate doping concentration"*)
    parameter real NGATE=0.0e16 from[0:inf) ;
    parameter real LNGATE = 0.0;
    parameter real WNGATE = 0.0;
    parameter real PNGATE = 0.0;
    (*units="cm⁻³", desc="Source/drain doping concentration"*)
    parameter real NSD=1.0e20 from[0:inf) ;
    parameter real LNSD = 0.0;
    parameter real WNSD = 0.0;
    parameter real PNSD = 0.0;
    (*units="m", desc="Doping depth"*)
    parameter real XT=1.55e-7 from[0:inf) ;
    parameter real LXT = 0.0;
    parameter real WXT = 0.0;
    parameter real PXT = 0.0;
    // phi - 7.7348e-4*NDEP * XT * XT - handled
    (*units="V", desc="Vbs at which the depletion region width equals XT"*)
    parameter real VBX=0.0 from[0:inf) ;
    parameter real LVBX = 0.0;
    parameter real WVBX = 0.0;
    parameter real PVBX = 0.0;
    (*units="Ω/□", desc="Source/drain sheet resistance"*)
    parameter real RSH=0.0 from[0:inf) ;
    (*units="Ω/□", desc="Gate electrode sheet resistance"*)
    parameter real RSHG=0.1 from[0:inf) ;

    // Basic Model Parameters
    (*units="V", desc="Long-channel threshold voltage at Vbs=0"*)
    parameter real VTH0=0.7 * TYPE;
    parameter real LVTH0 = 0.0;
    parameter real WVTH0 = 0.0;
    parameter real PVTH0 = 0.0;
    (*units="V", type="instance", desc="Zero bias threshold voltage variation"*)
    parameter real DELVTO=0.0;
    (*units="", type="instance", desc="Low field mobility multiplier"*)
    parameter real MULU0=1.0;
    (*units="V", desc="Flat-band voltage"*)
    parameter real VFB=-1.0;
    parameter real LVFB = 0.0;
    parameter real WVFB = 0.0;
    parameter real PVFB = 0.0;
    (*units="V", desc="Gate voltage at which EOT is measured"*)
    parameter real VDDEOT=1.5 * TYPE;
    (*units="um", desc="Effective gate length at which EOT is measured"*)
    parameter real LEFFEOT=1;
    (*units="um", desc="Effective width at which EOT is measured"*)
    parameter real WEFFEOT=10;
    // FIXME: TEMPEOT is in Celcius here but if not provided it is set in Kelvin (ngspice doesn't convert to Kelvin)
    (*units="°C", desc="Temperature at which EOT is measured"*)
    parameter real TEMPEOT=27;
    (*units="V", desc="Non-uniform vertical doping effect on surface potential"*)
    parameter real PHIN=0.0;
    parameter real LPHIN = 0.0;
    parameter real WPHIN = 0.0;
    parameter real PPHIN = 0.0;
    (*units="eV", desc="Electron affinity of substrate"*)
    parameter real EASUB=4.05;
    (*units="V", desc="Dielectric constant of substrate relative to vacuum"*)
    parameter real EPSRSUB=11.7;
    (*units="V", desc="Dielectric constant of gate relative to vacuum"*)
    parameter real EPSRGATE=11.7;
    // FIXME: should NI0SUB be in 1.45e16/m³
    (*units="1/cm³", desc="Intrinsic carrier concentration at T=300.15K"*)
    parameter real NI0SUB=1.45e10;
    (*units="eV", desc="Band-gap of substrate at T=0K"*)
    parameter real BG0SUB=1.16;
    (*units="eV/K", desc="First parameter of band-gap change due to temperature"*)
    parameter real TBGASUB=7.02e-4;
    (*units="K", desc="Second parameter of band- gap change due to temperature"*)
    parameter real TBGBSUB=1108.0;
    (*units="", desc="Density of states parameter to control charge centroid"*)
    parameter real ADOS=1.0;
    (*units="", desc="Density of states parameter to control charge centroid"*)
    parameter real BDOS=1.0;
    (*units="√V", desc="First-order body bias coefficient"*)
    parameter real K1=0.5;
    parameter real LK1 = 0.0;
    parameter real WK1 = 0.0;
    parameter real PK1 = 0.0;
    (*units="", desc="Second-order body bias coefficient"*)
    parameter real K2=0.0;
    parameter real LK2 = 0.0;
    parameter real WK2 = 0.0;
    parameter real PK2 = 0.0;
    (*units="", desc="Narrow width coefficient"*)
    parameter real K3=80.0;
    parameter real LK3 = 0.0;
    parameter real WK3 = 0.0;
    parameter real PK3 = 0.0;
    (*units="V⁻¹", desc="Body effect coefficient of K3"*)
    parameter real K3B=0.0;
    parameter real LK3B = 0.0;
    parameter real WK3B = 0.0;
    parameter real PK3B = 0.0;
    (*units="m", desc="Narrow width parameter"*)
    parameter real W0=2.5e-6;
    parameter real LW0 = 0.0;
    parameter real WW0 = 0.0;
    parameter real PW0 = 0.0;
    (*units="m", desc="Lateral non-uniform doping parameter at Vbs = 0"*)
    parameter real LPE0=1.74e-7;
    parameter real LLPE0 = 0.0;
    parameter real WLPE0 = 0.0;
    parameter real PLPE0 = 0.0;
    (*units="m", desc="Lateral non-uniform doping effect on K1"*)
    parameter real LPEB=0.0;
    parameter real LLPEB = 0.0;
    parameter real WLPEB = 0.0;
    parameter real PLPEB = 0.0;
    (*units="V", desc="Maximum applied body bias in VTH0 calculation"*)
    parameter real VBM=-3.0;
    parameter real LVBM = 0.0;
    parameter real WVBM = 0.0;
    parameter real PVBM = 0.0;
    (*units="", desc="First coefficient of short-channel effect on Vth"*)
    parameter real DVT0=2.2;
    parameter real LDVT0 = 0.0;
    parameter real WDVT0 = 0.0;
    parameter real PDVT0 = 0.0;
    (*units="", desc="Second coefficient of short-channel effect on Vth"*)
    parameter real DVT1=0.53;
    parameter real LDVT1 = 0.0;
    parameter real WDVT1 = 0.0;
    parameter real PDVT1 = 0.0;
    (*units="V⁻¹", desc="Body-bias coefficient of short-channel effect on Vth"*)
    parameter real DVT2=-0.032;
    parameter real LDVT2 = 0.0;
    parameter real WDVT2 = 0.0;
    parameter real PDVT2 = 0.0;
    (*units="m", desc="Coefficient of drain-induced Vth shift for long-channel devices with pocket implant"*)
    parameter real DVTP0=0.0;
    parameter real LDVTP0 = 0.0;
    parameter real WDVTP0 = 0.0;
    parameter real PDVTP0 = 0.0;
    (*units="V⁻¹", desc="Coefficient of drain-induced Vth shift for long-channel devices with pocket implant"*)
    parameter real DVTP1=0.0;
    parameter real LDVTP1 = 0.0;
    parameter real WDVTP1 = 0.0;
    parameter real PDVTP1 = 0.0;
    (*units="V m^DVTP3", desc="Coefficient of drain-induced Vth shift for long-channel devices with pocket implant"*)
    parameter real DVTP2=0.0;
    parameter real LDVTP2 = 0.0;
    parameter real WDVTP2 = 0.0;
    parameter real PDVTP2 = 0.0;
    (*units="0.0", desc="Coefficient of drain-induced Vth shift for long-channel devices with pocket implant"*)
    parameter real DVTP3=0.0;
    parameter real LDVTP3 = 0.0;
    parameter real WDVTP3 = 0.0;
    parameter real PDVTP3 = 0.0;
    (*units="V⁻¹", desc="Coefficient of drain-induced Vth shift for long-channel devices with pocket implant"*)
    parameter real DVTP4=0.0;
    parameter real LDVTP4 = 0.0;
    parameter real WDVTP4 = 0.0;
    parameter real PDVTP4 = 0.0;
    (*units="V", desc="Coefficient of drain-induced Vth shift for long-channel devices with pocket implant"*)
    parameter real DVTP5=0.0;
    parameter real LDVTP5 = 0.0;
    parameter real WDVTP5 = 0.0;
    parameter real PDVTP5 = 0.0;
    (*units="V⁻¹", desc="First coefficient of narrow width effect on V th for small channel length"*)
    parameter real DVT0W=0.0;
    parameter real LDVT0W = 0.0;
    parameter real WDVT0W = 0.0;
    parameter real PDVT0W = 0.0;
    (*units="m⁻¹", desc="Second coefficient of narrow width effect on V th for small channel length"*)
    parameter real DVT1W=5.3e6;
    parameter real LDVT1W = 0.0;
    parameter real WDVT1W = 0.0;
    parameter real PDVT1W = 0.0;
    (*units="V⁻¹", desc="Body-bias coefficient of narrow width effect for small channel length"*)
    parameter real DVT2W=-0.032;
    parameter real LDVT2W = 0.0;
    parameter real WDVT2W = 0.0;
    parameter real PDVT2W = 0.0;
    (*units="m²/(V s)", desc="Low-field mobility"*)
    parameter real U0=TYPE == `ntype ? 0.067 : 0.025;
    parameter real LU0 = 0.0;
    parameter real WU0 = 0.0;
    parameter real PU0 = 0.0;
    (*units="m/V", desc="Coefficient of first-order mobility degradation due to vertical field"*)
    parameter real UA=MOBMOD == 0 || MOBMOD == 1 ? 1.0e-9 : 1.0e-15;
    parameter real LUA = 0.0;
    parameter real WUA = 0.0;
    parameter real PUA = 0.0;
    (*units="m²/V²", desc="Coefficient of second-order mobility degradation due to vertical field"*)
    parameter real UB=1.0e-19;
    parameter real LUB = 0.0;
    parameter real WUB = 0.0;
    parameter real PUB = 0.0;
    (*units="m/V²", desc="Coefficient of mobility degradation due to body-bias effect"*)
    parameter real UC=MOBMOD == 1 || MOBMOD == 5 ? -0.0465 : -0.0465e-9;
    parameter real LUC = 0.0;
    parameter real WUC = 0.0;
    parameter real PUC = 0.0;
    (*units="m⁻²", desc="Mobility Coulumb scattering coefficient"*)
    parameter real UD=0.0;
    parameter real LUD = 0.0;
    parameter real WUD = 0.0;
    parameter real PUD = 0.0;
    (*units="", desc="Coulombic scattering exponent"*)
    parameter real UCS=TYPE == `ntype ? 1.67 : 1.0;
    parameter real LUCS = 0.0;
    parameter real WUCS = 0.0;
    parameter real PUCS = 0.0;
    (*units="m⁻²", desc="Mobility channel length coefficient"*)
    parameter real UP=0.0;
    parameter real LUP = 0.0;
    parameter real WUP = 0.0;
    parameter real PUP = 0.0;
    (*units="m", desc="Mobility channel length exponential coefficient"*)
    parameter real LP=1e-8;
    parameter real LLP = 0.0;
    parameter real WLP = 0.0;
    parameter real PLP = 0.0;
    (*units="", desc="Exponent for mobility degradation of MOBMOD=2"*)
    parameter real EU=TYPE == `ntype ? 1.67 : 1.0;
    parameter real LEU = 0.0;
    parameter real WEU = 0.0;
    parameter real PEU = 0.0;
    (*units="m/s", desc="Saturation velocity"*)
    parameter real VSAT=8.0e4;
    parameter real LVSAT = 0.0;
    parameter real WVSAT = 0.0;
    parameter real PVSAT = 0.0;
    (*units="", desc="Coefficient of channel-length dependence of bulk charge effect"*)
    parameter real A0=1.0;
    parameter real LA0 = 0.0;
    parameter real WA0 = 0.0;
    parameter real PA0 = 0.0;
    (*units="V⁻¹", desc="Coefficient of Vgs dependence of bulk charge effect"*)
    parameter real AGS=0.0;
    parameter real LAGS = 0.0;
    parameter real WAGS = 0.0;
    parameter real PAGS = 0.0;
    (*units="m", desc="Bulk charge effect coefficient for channel width"*)
    parameter real B0=0.0;
    parameter real LB0 = 0.0;
    parameter real WB0 = 0.0;
    parameter real PB0 = 0.0;
    (*units="m", desc="Bulk charge effect width offset"*)
    parameter real B1=0.0;
    parameter real LB1 = 0.0;
    parameter real WB1 = 0.0;
    parameter real PB1 = 0.0;
    (*units="V⁻¹", desc="Body-bias coefficient of bulk charge effect"*)
    parameter real KETA=-0.47;
    parameter real LKETA = 0.0;
    parameter real WKETA = 0.0;
    parameter real PKETA = 0.0;
    (*units="V⁻¹", desc="First non-saturation effect parameter"*)
    parameter real A1=0.0;
    parameter real LA1 = 0.0;
    parameter real WA1 = 0.0;
    parameter real PA1 = 0.0;
    (*units="", desc="Second non-saturation factor"*)
    parameter real A2=1.0;
    parameter real LA2 = 0.0;
    parameter real WA2 = 0.0;
    parameter real PA2 = 0.0;
    (*units="m", desc="Channel-width offset parameter"*)
    parameter real WINT=0.0;
    (*units="m", desc="Channel-length offset parameter"*)
    parameter real LINT=0.0;
    (*units="m/V", desc="Coefficient of gate bias dependence of Weff"*)
    parameter real DWG=0.0;
    parameter real LDWG = 0.0;
    parameter real WDWG = 0.0;
    parameter real PDWG = 0.0;
    (*units="m/√V", desc="Coefficient of body bias dependence of Weff bias dependence"*)
    parameter real DWB=0.0;
    parameter real LDWB = 0.0;
    parameter real WDWB = 0.0;
    parameter real PDWB = 0.0;
    (*units="V", desc="Offset voltage in subthreshold region for large W and L"*)
    parameter real VOFF=-0.08;
    parameter real LVOFF = 0.0;
    parameter real WVOFF = 0.0;
    parameter real PVOFF = 0.0;
    (*units="mV", desc="Channel-length dependence of VOFF"*)
    parameter real VOFFL=0.0;
    (*units="", desc="Vgsteff fitting parameter for moderate inversion condition"*)
    parameter real MINV=0.0;
    parameter real LMINV = 0.0;
    parameter real WMINV = 0.0;
    parameter real PMINV = 0.0;
    (*units="", desc="Subthreshold swing factor"*)
    parameter real NFACTOR=1.0;
    parameter real LNFACTOR = 0.0;
    parameter real WNFACTOR = 0.0;
    parameter real PNFACTOR = 0.0;
    (*units="", desc="DIBL coefficient in subthreshold region"*)
    parameter real ETA0=0.08;
    parameter real LETA0 = 0.0;
    parameter real WETA0 = 0.0;
    parameter real PETA0 = 0.0;
    (*units="V⁻¹", desc="Body-bias coefficient for the subthreshold DIBL effect"*)
    parameter real ETAB=-0.07;
    parameter real LETAB = 0.0;
    parameter real WETAB = 0.0;
    parameter real PETAB = 0.0;

    (*units="", desc="Channel-length dependence of DIBL effect on Rout"*)
    parameter real DROUT=0.56;
    parameter real LDROUT = 0.0;
    parameter real WDROUT = 0.0;
    parameter real PDROUT = 0.0;
    (*units="", desc="DIBL coefficient exponentin subthreshold region"*)
    parameter real DSUB=DROUT;
    parameter real LDSUB = 0.0;
    parameter real WDSUB = 0.0;
    parameter real PDSUB = 0.0;
    (*units="F/m²", desc="Interface trap capacitance"*)
    parameter real CIT=0.0;
    parameter real LCIT = 0.0;
    parameter real WCIT = 0.0;
    parameter real PCIT = 0.0;
    (*units="F/m²", desc="coupling capacitance between source/ drain and channel"*)
    parameter real CDSC=2.4e-4;
    parameter real LCDSC = 0.0;
    parameter real WCDSC = 0.0;
    parameter real PCDSC = 0.0;
    (*units="F/(V m²)", desc="Body-bias sensitivity of Cdsc"*)
    parameter real CDSCB=0.0;
    parameter real LCDSCB = 0.0;
    parameter real WCDSCB = 0.0;
    parameter real PCDSCB = 0.0;
    (*units="F/(V m²)", desc="Drain-bias sensitivity of CDSC"*)
    parameter real CDSCD=0.0;
    parameter real LCDSCD = 0.0;
    parameter real WCDSCD = 0.0;
    parameter real PCDSCD = 0.0;
    (*units="", desc="Channel length modulation parameter"*)
    parameter real PCLM=1.3;
    parameter real LPCLM = 0.0;
    parameter real WPCLM = 0.0;
    parameter real PPCLM = 0.0;
    (*units="", desc="Parameter for DIBL effect on Rout"*)
    parameter real PDIBLC1=0.39;
    parameter real LPDIBLC1 = 0.0;
    parameter real WPDIBLC1 = 0.0;
    parameter real PPDIBLC1 = 0.0;
    (*units="", desc="Parameter for DIBL effect on Rout"*)
    parameter real PDIBLC2=0.0086;
    parameter real LPDIBLC2 = 0.0;
    parameter real WPDIBLC2 = 0.0;
    parameter real PPDIBLC2 = 0.0;
    (*units="V⁻¹", desc="Body bias coefficient of DIBL effect on Rout"*)
    parameter real PDIBLCB=0.0;
    parameter real LPDIBLCB = 0.0;
    parameter real WPDIBLCB = 0.0;
    parameter real PPDIBLCB = 0.0;
    (*units="V/m", desc="First substrate current induced body-effect parameter"*)
    parameter real PSCBE1=4.24e8;
    parameter real LPSCBE1 = 0.0;
    parameter real WPSCBE1 = 0.0;
    parameter real PPSCBE1 = 0.0;
    (*units="m/V", desc="Second substrate current induced body-effect parameter"*)
    parameter real PSCBE2=1.0e-5;
    parameter real LPSCBE2 = 0.0;
    parameter real WPSCBE2 = 0.0;
    parameter real PPSCBE2 = 0.0;
    (*units="", desc="Gate-bias dependence of Early voltage"*)
    parameter real PVAG=0.0;
    parameter real LPVAG = 0.0;
    parameter real WPVAG = 0.0;
    parameter real PPVAG = 0.0;
    (*units="V", desc="Parameter for DC Vdseff"*)
    parameter real DELTA=0.01;
    parameter real LDELTA = 0.0;
    parameter real WDELTA = 0.0;
    parameter real PDELTA = 0.0;
    (*units="V/√m", desc="Effect of pocket implant on Rout degradation"*)
    parameter real FPROUT=0.0;
    parameter real LFPROUT = 0.0;
    parameter real WFPROUT = 0.0;
    parameter real PFPROUT = 0.0;
    (*units="V⁻¹", desc="Impact of drain-induced Vth shift on Rout"*)
    parameter real PDITS=0.0;
    parameter real LPDITS = 0.0;
    parameter real WPDITS = 0.0;
    parameter real PPDITS = 0.0;

    (*units="m⁻¹", desc="Channel-length dependence of drain-induced V th shift for Rout"*)
    parameter real PDITSL=0.0;
    (*units="V⁻¹", desc="V ds dependence of drain-induced V th shift for Rout"*)
    parameter real PDITSD=0.0;
    parameter real LPDITSD = 0.0;
    parameter real WPDITSD = 0.0;
    parameter real PPDITSD = 0.0;
    (*units="", desc="Velocity overshoot coefficient"*)
    parameter real LAMBDA=0.0;
    parameter real LLAMBDA = 0.0;
    parameter real WLAMBDA = 0.0;
    parameter real PLAMBDA = 0.0;
    (*units="m/s", desc="Thermal velocity"*)
    parameter real VTL=2.05e5;
    parameter real LVTL = 0.0;
    parameter real WVTL = 0.0;
    parameter real PVTL = 0.0;
    (*units="m", desc="Velocity back scattering coefficient (LC)"*)
    parameter real LC=0.0;
    (*units="", desc="Velocity back scattering coefficient (XN)"*)
    parameter real XN=3.0;
    parameter real LXN = 0.0;
    parameter real WXN = 0.0;
    parameter real PXN = 0.0;

    // Parameters for Asymmetric and Bias-Dependent Rds Model
    (*units="", desc="Channel-width dependence parameter of LDD resistance"*)
    parameter real WR=1.0;
    parameter real LWR = 0.0;
    parameter real WWR = 0.0;
    parameter real PWR = 0.0;
    (*units="Ω μm", desc="Zero bias LDD resistance per unit width for RDSMOD=0"*)
    parameter real RDSW=200.0*WR;
    parameter real LRDSW = 0.0;
    parameter real WRDSW = 0.0;
    parameter real PRDSW = 0.0;
    (*units="Ω μm", desc="LDD resistance per unit width at high V gs and zero V bs for RDSMOD=0"*)
    parameter real RDSWMIN=0.0*WR;
    (*units="Ω μm", desc="Zero bias lightly-doped drain resistance Rd(V) per unit width for RDSMOD=1"*)
    parameter real RDW=100.0*WR;
    parameter real LRDW = 0.0;
    parameter real WRDW = 0.0;
    parameter real PRDW = 0.0;
    (*units="Ω μm", desc="Lightly-doped drain resistance per unit width at high V gs and zero V bs for RDSMOD=1"*)
    parameter real RDWMIN=0.0;
    (*units="Ω μm", desc="Zero bias lightly-doped source resistance Rs(V) per unit width for RDSMOD=1"*)
    parameter real RSW=100.0*WR;
    parameter real LRSW = 0.0;
    parameter real WRSW = 0.0;
    parameter real PRSW = 0.0;
    (*units="Ω μm", desc="Lightly-doped source resistance per unit width at high V gs and zero V bs for RDSMOD=1"*)
    parameter real RSWMIN=0.0*WR;
    (*units="V⁻¹", desc="Gate-bias dependence of LDD resistance"*)
    parameter real PRWG=1.0;
    parameter real LPRWG = 0.0;
    parameter real WPRWG = 0.0;
    parameter real PPRWG = 0.0;
    (*units="1/√V", desc="Body-bias dependence of LDD resistance"*)
    parameter real PRWB=0.0;
    parameter real LPRWB = 0.0;
    parameter real WPRWB = 0.0;
    parameter real PPRWB = 0.0;
    (*units="", type="instance", desc="Number of source diffusion squares"*)
    parameter real NRS=1.0;
    (*units="", type="instance", desc="Number of drain diffusion squares"*)
    parameter real NRD=1.0;

    // A.5 Impact Ionization Current Model Parameters
    (*units="m/V", desc="First parameter of impact ionization current"*)
    parameter real ALPHA0=0.0;
    parameter real LALPHA0 = 0.0;
    parameter real WALPHA0 = 0.0;
    parameter real PALPHA0 = 0.0;
    (*units="V⁻¹", desc="Channel length scaling parameter of impact ionization current"*)
    parameter real ALPHA1=0.0;
    parameter real LALPHA1 = 0.0;
    parameter real WALPHA1 = 0.0;
    parameter real PALPHA1 = 0.0;
    (*units="V⁻¹", desc="First V ds dependent parameter of impact ionization current"*)
    parameter real BETA0=0.0;
    parameter real LBETA0 = 0.0;
    parameter real WBETA0 = 0.0;
    parameter real PBETA0 = 0.0;

    // A.6 Gate-Induced Drain Leakage Model Parameters
    (*units="mho", desc="Pre-exponential coefficient for GIDL"*)
    parameter real AGIDL=0.0;
    parameter real LAGIDL = 0.0;
    parameter real WAGIDL = 0.0;
    parameter real PAGIDL = 0.0;
    (*units="V/m", desc="Exponential coefficient for GIDL"*)
    parameter real BGIDL=2.3e9;
    parameter real LBGIDL = 0.0;
    parameter real WBGIDL = 0.0;
    parameter real PBGIDL = 0.0;
    (*units="V³", desc="Parameter for body-bias effect on GIDL"*)
    parameter real CGIDL=0.5;
    parameter real LCGIDL = 0.0;
    parameter real WCGIDL = 0.0;
    parameter real PCGIDL = 0.0;
    (*units="V", desc="Fitting parameter for band bending for GIDL"*)
    parameter real EGIDL=0.8;
    parameter real LEGIDL = 0.0;
    parameter real WEGIDL = 0.0;
    parameter real PEGIDL = 0.0;
    (*units="", desc="Parameter for GIDL gate bias dependence"*)
    parameter real RGIDL=1.0;
    parameter real LRGIDL = 0.0;
    parameter real WRGIDL = 0.0;
    parameter real PRGIDL = 0.0;
    (*units="V", desc="Parameter for GIDL body bias dependence"*)
    parameter real KGIDL=0.0;
    parameter real LKGIDL = 0.0;
    parameter real WKGIDL = 0.0;
    parameter real PKGIDL = 0.0;
    (*units="V", desc="Parameter for GIDL body bias dependence"*)
    parameter real FGIDL=1.0;
    parameter real LFGIDL = 0.0;
    parameter real WFGIDL = 0.0;
    parameter real PFGIDL = 0.0;
    (*units="mho", desc="Pre-exponential coefficient for GISL"*)
    parameter real AGISL=AGIDL;
    parameter real LAGISL = 0.0;
    parameter real WAGISL = 0.0;
    parameter real PAGISL = PAGIDL;
    (*units="V/m", desc="Exponential coefficient for GISL"*)
    parameter real BGISL=BGIDL;
    parameter real LBGISL = 0.0;
    parameter real WBGISL = 0.0;
    parameter real PBGISL = PBGIDL;
    (*units="V³", desc="Parameter for body-bias effect on GISL"*)
    parameter real CGISL=CGIDL;
    parameter real LCGISL = 0.0;
    parameter real WCGISL = 0.0;
    parameter real PCGISL = PCGIDL;
    (*units="V", desc="Fitting parameter for band bending for GISL"*)
    parameter real EGISL=EGIDL;
    parameter real LEGISL = 0.0;
    parameter real WEGISL = 0.0;
    parameter real PEGISL = PEGIDL;
    (*units="", desc="Parameter for GIDL gate bias dependence"*)
    parameter real RGISL=RGIDL;
    parameter real LRGISL = 0.0;
    parameter real WRGISL = 0.0;
    parameter real PRGISL = PRGIDL;
    (*units="V", desc="Parameter for GISL bodybias dependence"*)
    parameter real KGISL=KGIDL;
    parameter real LKGISL = 0.0;
    parameter real WKGISL = 0.0;
    parameter real PKGISL = PKGIDL;
    (*units="V", desc="Parameter for GISL body bias dependence"*)
    parameter real FGISL=FGIDL;
    parameter real LFGISL = 0.0;
    parameter real WFGISL = 0.0;
    parameter real PFGISL = PFGIDL;

    // A.7 Gate-Induced Drain Leakage Model Parameters
    (*units="√(Fs²/g)m⁻¹", desc="Parameter for Igb in accumulation"*)
    parameter real AIGBACC=1.36e-2;
    parameter real LAIGBACC = 0.0;
    parameter real WAIGBACC = 0.0;
    parameter real PAIGBACC = 0.0;
    (*units="√(Fs²/g)m⁻¹V⁻¹", desc="Parameter for Igb in accumulation"*)
    parameter real BIGBACC=1.71e-3;
    parameter real LBIGBACC = 0.0;
    parameter real WBIGBACC = 0.0;
    parameter real PBIGBACC = 0.0;
    (*units="V⁻¹", desc="Parameter for Igb in accumulation"*)
    parameter real CIGBACC=0.075;
    parameter real LCIGBACC = 0.0;
    parameter real WCIGBACC = 0.0;
    parameter real PCIGBACC = 0.0;
    (*units="", desc="Parameter for Igb in accumulation"*)
    parameter real NIGBACC=1.0;
    parameter real LNIGBACC = 0.0;
    parameter real WNIGBACC = 0.0;
    parameter real PNIGBACC = 0.0;
    (*units="√(Fs²/g)m⁻¹", desc="Parameter for Igb in inversion"*)
    parameter real AIGBINV=1.11e-2;
    parameter real LAIGBINV = 0.0;
    parameter real WAIGBINV = 0.0;
    parameter real PAIGBINV = 0.0;
    (*units="√(Fs²/g)m⁻¹V⁻¹", desc="Parameter for Igb in inversion"*)
    parameter real BIGBINV=9.49e-4;
    parameter real LBIGBINV = 0.0;
    parameter real WBIGBINV = 0.0;
    parameter real PBIGBINV = 0.0;
    (*units="V⁻¹", desc="Parameter for Igb in inversion"*)
    parameter real CIGBINV=0.006;
    parameter real LCIGBINV = 0.0;
    parameter real WCIGBINV = 0.0;
    parameter real PCIGBINV = 0.0;
    (*units="V", desc="Parameter for Igb in inversion"*)
    parameter real EIGBINV=1.1;
    parameter real LEIGBINV = 0.0;
    parameter real WEIGBINV = 0.0;
    parameter real PEIGBINV = 0.0;
    (*units="", desc="Parameter for Igb in inversion"*)
    parameter real NIGBINV=3.0;
    parameter real LNIGBINV = 0.0;
    parameter real WNIGBINV = 0.0;
    parameter real PNIGBINV = 0.0;
    (*units="√(Fs²/g)m⁻¹", desc="Parameter for Igcs and Igcd"*)
    parameter real AIGC=TYPE == `ntype ? 1.36e-2 : 9.8e-3;
    parameter real LAIGC = 0.0;
    parameter real WAIGC = 0.0;
    parameter real PAIGC = 0.0;
    (*units="√(Fs²/g)m⁻¹V⁻¹", desc="Parameter for Igcs and Igcd"*)
    parameter real BIGC=TYPE == `ntype ? 1.71e-3 : 7.59e-4;
    parameter real LBIGC = 0.0;
    parameter real WBIGC = 0.0;
    parameter real PBIGC = 0.0;

    (*units="V⁻¹", desc="Parameter for Igcs and Igcd"*)
    parameter real CIGC=TYPE == `ntype ? 0.075 : 0.03;
    parameter real LCIGC = 0.0;
    parameter real WCIGC = 0.0;
    parameter real PCIGC = 0.0;
    (*units="√(Fs²/g)m⁻¹", desc="Parameter for Igs"*)
    parameter real AIGS=AIGSD;
    parameter real LAIGS = 0.0;
    parameter real WAIGS = 0.0;
    parameter real PAIGS = 0.0;
    (*units="√(Fs²/g)m⁻¹V⁻¹", desc="Parameter for Igs"*)
    parameter real BIGS=BIGSD;
    parameter real LBIGS = 0.0;
    parameter real WBIGS = 0.0;
    parameter real PBIGS = 0.0;
    (*units="V⁻¹", desc="Parameter for Igs"*)
    parameter real CIGS=CIGSD;
    parameter real LCIGS = 0.0;
    parameter real WCIGS = 0.0;
    parameter real PCIGS = 0.0;
    (*units="", desc="Source/drain overlap length for Igs"*)
    parameter real DLCIG=LINT;
    (*units="√(Fs²/g)m⁻¹", desc="Parameter for Igd"*)
    parameter real AIGD=TYPE == `ntype ? 1.36e-2 : 9.8e-3;
    parameter real LAIGD = 0.0;
    parameter real WAIGD = 0.0;
    parameter real PAIGD = 0.0;
    (*units="√(Fs²/g)m⁻¹V⁻¹", desc="Parameter for Igd"*)
    parameter real BIGD=TYPE == `ntype ? 1.71e-3 : 7.59e-4;
    parameter real LBIGD = 0.0;
    parameter real WBIGD = 0.0;
    parameter real PBIGD = 0.0;
    (*units="", desc="Parameter for Igd"*)
    parameter real CIGD=TYPE == `ntype ? 0.075 : 0.03;
    parameter real LCIGD = 0.0;
    parameter real WCIGD = 0.0;
    parameter real PCIGD = 0.0;
    (*units="", desc="Source/drain overlap length for Igd"*)
    parameter real DLCIGD=DLCIG;
    (*units="", desc="Parameter for Igcs, Igcd, Igs and Igd"*)
    parameter real NIGC=1.0;
    parameter real LNIGC = 0.0;
    parameter real WNIGC = 0.0;
    parameter real PNIGC = 0.0;
    (*units="", desc="Factor for the gate oxide thickness in source/drain overlap regions"*)
    parameter real POXEDGE=1.0;
    parameter real LPOXEDGE = 0.0;
    parameter real WPOXEDGE = 0.0;
    parameter real PPOXEDGE = 0.0;

    (*units="", desc="Vds dependence of Igcs and Igcd"*)
    parameter real PIGCD=1.0;
    parameter real LPIGCD = 0.0;
    parameter real WPIGCD = 0.0;
    parameter real PPIGCD = 0.0;
    (*units="", desc="Exponent for the gate oxide ratio"*)
    parameter real NTOX=1.0;
    parameter real LNTOX = 0.0;
    parameter real WNTOX = 0.0;
    parameter real PNTOX = 0.0;
    (*units="m", desc="Nominal gate oxide thickness for gate dielectric tunneling current model only"*)
    parameter real TOXREF=3.0e-9;
    (*units="V", desc="Flatband Voltage Offset Parameter"*)
    parameter real VFBSDOFF=0.0;
    parameter real LVFBSDOFF = 0.0;
    parameter real WVFBSDOFF = 0.0;
    parameter real PVFBSDOFF = 0.0;

    // A.8 Charge and Capacitance Model Parameters
    (*units="", desc="Charge partitioning parameter"*)
    parameter real XPART=0.0;
    // $param_given(DLC) && DLC > 0.0 ? DLC * coxe * CGSL : 0.6 * XJ * coxe - handled below
    (*units="F/m", desc="Non LDD region source-gate overlap capacitance per unit channel width"*)
    parameter real CGSO=0.0 from[0.0:inf) ;
    (*units="F/m", desc="Non LDD region drain-gate overlap capacitance per unit channel width"*)
    parameter real CGDO=0.0 from[0.0:inf) ;
    (*units="F/m", desc="Gate-bulk overlap capacitanceper unit channel length"*)
    parameter real CGBO=0.0 from[0.0:inf) ;
    (*units="F/m", desc="Overlap capacitance between gate and lightly-doped source region"*)
    parameter real CGSL=0.0;
    parameter real LCGSL = 0.0;
    parameter real WCGSL = 0.0;
    parameter real PCGSL = 0.0;
    (*units="F/m", desc="Overlap capacitance between gate and lightly-doped drain region"*)
    parameter real CGDL=0.0;
    parameter real LCGDL = 0.0;
    parameter real WCGDL = 0.0;
    parameter real PCGDL = 0.0;
    (*units="V", desc="Coefficient of bias-dependent overlap capacitance for the source side"*)
    parameter real CKAPPAS=0.6;
    parameter real LCKAPPAS = 0.0;
    parameter real WCKAPPAS = 0.0;
    parameter real PCKAPPAS = 0.0;
    (*units="V", desc="Coefficient of bias-dependent overlap capacitance for the drain side"*)
    parameter real CKAPPAD=CKAPPAS;
    parameter real LCKAPPAD = 0.0;
    parameter real WCKAPPAD = 0.0;
    parameter real PCKAPPAD = 0.0;
    (*units="F/m", desc="Fringing field capacitance"*)
    parameter real CF=2.0 * EPSROX * `EPS0 / `M_PI * ln(1.0 + 0.4e-6 / TOXE);
    parameter real LCF = 0.0;
    parameter real WCF = 0.0;
    parameter real PCF = 0.0;
    (*units="m", desc="Constant term for the short channel model"*)
    parameter real CLC=1.0e-7;
    parameter real LCLC = 0.0;
    parameter real WCLC = 0.0;
    parameter real PCLC = 0.0;
    (*units="", desc="Exponential term for the short channel model"*)
    parameter real CLE=0.6;
    parameter real LCLE = 0.0;
    parameter real WCLE = 0.0;
    parameter real PCLE = 0.0;
    (*units="m", desc="Channel-length offset parameter for CV model"*)
    parameter real DLC=LINT;
    (*units="m", desc="Channel-width offset parameter for CV model"*)
    parameter real DWC=WINT;
    (*units="V", desc="Flat-band voltage parameter (for CAPMOD=0 only)"*)
    parameter real VFBCV=-1.0;
    parameter real LVFBCV = 0.0;
    parameter real WVFBCV = 0.0;
    parameter real PVFBCV = 0.0;
    (*units="V", desc="CV parameter in V gsteff,CV for weak to strong inversion"*)
    parameter real NOFF=1.0;
    parameter real LNOFF = 0.0;
    parameter real WNOFF = 0.0;
    parameter real PNOFF = 0.0;
    (*units="V", desc="CV parameter in V gsteff,CV for week to strong inversion"*)
    parameter real VOFFCV=0.0;
    parameter real LVOFFCV = 0.0;
    parameter real WVOFFCV = 0.0;
    parameter real PVOFFCV = 0.0;

    (*units="", desc="Channel-length dependence of VOFFCVL"*)
    parameter real VOFFCVL=0.0;
    (*units="", desc="Vgsteff,CV fitting parameter for moderate inversion condition"*)
    parameter real MINVCV=0.0;
    parameter real LMINVCV = 0.0;
    parameter real WMINVCV = 0.0;
    parameter real PMINVCV = 0.0;
    (*units="m/V", desc="Exponential coefficient for charge thickness in CAPMOD=2 for accumulation and depletion regions"*)
    parameter real ACDE=1.0;
    parameter real LACDE = 0.0;
    parameter real WACDE = 0.0;
    parameter real PACDE = 0.0;
    (*units="", desc="Coefficient for the gate-bias dependent surface potential"*)
    parameter real MOIN=15.0;
    parameter real LMOIN = 0.0;
    parameter real WMOIN = 0.0;
    parameter real PMOIN = 0.0;

    // A.9 High-Speed/RF Model Parameters
    (*units="", desc="Parameter for distributed channel-resistance effect for both intrinsic-input resistance and charge-deficit NQS models"*)
    parameter real XRCRG1=12.;
    parameter real LXRCRG1 = 0.0;
    parameter real WXRCRG1 = 0.0;
    parameter real PXRCRG1 = 0.0;
    (*units="", desc="Parameter to account for the excess channel diffusion resistance for both intrinsic input resistance and charge- deficit NQS models"*)
    parameter real XRCRG2=1.0;
    parameter real LXRCRG2 = 0.0;
    parameter real WXRCRG2 = 0.0;
    parameter real PXRCRG2 = 0.0;
    (*units="Ω", type="both", desc="Resistance connected between bNodePrime and bNode"*)
    parameter real RBPB=50.0;
    (*units="Ω", type="both", desc="Resistance connected between bNodePrime and dbNode"*)
    parameter real RBPD=50.0;
    (*units="Ω", type="both", desc="Resistance connected between bNodePrime and sbNode"*)
    parameter real RBPS=50.0;
    (*units="Ω", type="both", desc="Resistance connected between dbNode and bNode"*)
    parameter real RBDB=50.0;

    (*units="Ω", type="both", desc="Resistance connected between sbNode and bNode"*)
    parameter real RBSB=50.0;
    (*units="1e-12mho", desc="Conductance in parallel with each of the five substrate resistances to avoid potential numerical instability due to unreasonably too large a substrate resistance"*)
    parameter real GBMIN=1.0e-12 from[1.0e-20:inf) ;
    (*units="Ω", desc="Scaling prefactor for RBPS"*)
    parameter real RBPS0=50.0 from[0.0:inf) ;
    (*units="", desc="Length Scaling parameter for RBPS"*)
    parameter real RBPSL=0.0;
    (*units="", desc="Width Scaling parameter for RBPS"*)
    parameter real RBPSW=0.0;
    (*units="", desc="Number of fingers Scaling parameter for RBPS"*)
    parameter real RBPSNF=0.0;
    (*units="Ω", desc="Scaling prefactor for RBPD"*)
    parameter real RBPD0=50.0 from[0.0:inf) ;
    (*units="", desc="Length Scaling parameter for RBPD"*)
    parameter real RBPDL=0.0;
    (*units="", desc="Width Scaling parameter for RBPD"*)
    parameter real RBPDW=0.0;
    (*units="", desc="Number of fingers Scaling parameter for RBPD"*)
    parameter real RBPDNF=0.0;
    (*units="Ω", desc="Scaling prefactor for RBPBX"*)
    parameter real RBPBX0=100.0 from[0.0:inf) ;
    (*units="", desc="Length Scaling parameter for RBPBX"*)
    parameter real RBPBXL=0.0;
    (*units="", desc="Width Scaling parameter for RBPBX"*)
    parameter real RBPBXW=0.0;
    (*units="", desc="Number of fingers Scaling parameter for RBPBX"*)
    parameter real RBPBXNF=0.0;
    (*units="Ω", desc="Scaling prefactor for RBPBY"*)
    parameter real RBPBY0=100.0 from[0.0:inf) ;
    (*units="", desc="Length Scaling parameter for RBPBY"*)
    parameter real RBPBYL=0.0;
    (*units="", desc="Width Scaling parameter for RBPBY"*)
    parameter real RBPBYW=0.0;
    (*units="", desc="Number of fingers Scaling parameter for RBPBY"*)
    parameter real RBPBYNF=0.0;
    (*units="Ω", desc="Scaling prefactor for RBSBX"*)
    parameter real RBSBX0=100.0 from[0.0:inf) ;
    (*units="Ω", desc="Scaling prefactor for RBSBY"*)
    parameter real RBSBY0=100.0 from[0.0:inf) ;
    (*units="Ω", desc="Scaling prefactor for RBDBX"*)
    parameter real RBDBX0=100.0 from[0.0:inf) ;

    (*units="Ω", desc="Scaling prefactor for RBDBY"*)
    parameter real RBDBY0=100.0 from[0.0:inf) ;
    (*units="", desc="Length Scaling parameter for RBSBX and RBDBX"*)
    parameter real RBSDBXL=0.0;
    (*units="", desc="Width Scaling parameter for RBSBX and RBDBX"*)
    parameter real RBSDBXW=0.0;
    (*units="", desc="Number of fingers Scaling parameter for RBSBX and RBDBX"*)
    parameter real RBSDBXNF=0.0;
    (*units="", desc="Length Scaling parameter for RBSBY and RBDBY"*)
    parameter real RBSDBYL=0.0;
    (*units="", desc="Width Scaling parameter for RBSBY and RBDBY"*)
    parameter real RBSDBYW=0.0;
    (*units="", desc="Number of fingers Scaling parameter for RBSBY and RBDBY"*)
    parameter real RBSDBYNF=0.0;

    // A.10 Flicker and Thermal Noise Model Parameters
    (*units="eV⁻¹s^(1-EF)m⁻¹", desc="Flicker noise parameter A"*)
    parameter real NOIA=TYPE == `ntype ? 6.25e41 : 6.118e40;
    (*units="eV⁻¹s^(1-EF)m⁻¹", desc="Flicker noise parameter B"*)
    parameter real NOIB=TYPE == `ntype ? 3.125e26 : 1.5e25;
    (*units="eV⁻¹s^(1-EF)m", desc="Flicker noise parameter C"*)
    parameter real NOIC=8.75;
    (*units="V/m", desc="Saturation field"*)
    parameter real EM=4.1e7;
    (*units="", desc="Flicker noise exponent"*)
    parameter real AF=1.0;
    (*units="", desc="Flicker noise frequency exponent"*)
    parameter real EF=1.0;
    (*units="s^(1-EFF)", desc="Flicker noise coefficient"*)
    parameter real KF=0.0;
    (*units="m", desc="Length Reduction Parameter Offset"*)
    parameter real LINTNOI=0.0;
    (*units="", desc="Noise factor for short-channel devices for TNOIMOD=0 only"*)
    parameter real NTNOI=1.0 from[0.0:inf) ;
    (*units="", desc="Coefficient of channel-length dependence of total channel thermal noise"*)
    parameter real TNOIA=1.5;
    (*units="", desc="Channel-length dependence parameter for channel thermal noise partitioning"*)
    parameter real TNOIB=3.5;
    (*units="", desc="Length dependent parameter for Correlation Coefficient"*)
    parameter real TNOIC=0.0;
    (*units="", desc="Thermal Noise Coefficient"*)
    parameter real RNOIA=0.577;

    (*units="", desc="Thermal Noise Coefficient"*)
    parameter real RNOIB=0.5164;
    (*units="", desc="Correlation Coefficient parameter"*)
    parameter real RNOIC=0.395;

    // A.11 Layout-Dependent Parasitic Model Parameters
    (*units="m", desc="Distance from S/D contact center to the gate edge"*)
    parameter real DMCG=0.0;
    (*units="m", desc="Distance from S/D contact center to the isolation edge in the channel-length direction"*)
    parameter real DMCI=DMCG;
    (*units="m", desc="Same as DMCG but for merged device only"*)
    parameter real DMDG=0.0;
    (*units="m", desc="DMCG of test structures"*)
    parameter real DMCGT=0.0;
    (*units="", type="instance", desc="Number of device fingers"*)
    parameter integer NF=1 from[1:inf) ;
    (*units="m", desc="Offset of the S/D junction width"*)
    parameter real DWJ=DWC;
    (*units="", type="instance", desc="Whether to minimize the number of drain or source diffusions for even-number fingered device"*)
    parameter integer MIN=0 from [0:1];
    (*units="m", type="both", desc="Distance from the gate contact to the channel edge"*)
    parameter real XGW=0.0;
    (*units="m",  desc="Offset of the gate length due to variations in patterning"*)
    parameter real XGL=0.0;
    (*units="m", desc="Channel length offset due to mask/ etch effect"*)
    parameter real XL=0.0;
    (*units="m", desc="Channel width offset due to mask/etch effect"*)
    parameter real XW=0.0;
    (*units="", type="both", desc="Number of gate contacts"*)
    parameter integer NGCON=1 from[1:2] ;

    // A.12 Asymmetric Source/Drain Junction Diode Model Parameters
    (*units="A", desc="Limiting current in reverse bias region (Source)"*)
    parameter real IJTHSREV=0.1 from[0.0:inf) ;
    (*units="A", desc="Limiting current in reverse bias region (Drain)"*)
    parameter real IJTHDREV=IJTHSREV from[0.0:inf) ;
    (*units="A", desc="Limiting current in forward bias region (Source)"*)
    parameter real IJTHSFWD=0.1 from[0.0:inf) ;
    (*units="A", desc="Limiting current in forward bias region (Drain)"*)
    parameter real IJTHDFWD=IJTHSFWD from[0.0:inf) ;
    (*units="", desc="Fitting parameter for diode breakdown (Source)"*)
    parameter real XJBVS=1.0 from[0.0:inf) ;
    (*units="", desc="Fitting parameter for diode breakdown (Drain)"*)
    parameter real XJBVD=XJBVS from[0.0:inf) ;
    (*units="V", desc="Breakdown voltage (Source)"*)
    parameter real BVS=10.0 from[0.0:inf) ;
    (*units="V", desc="Breakdown voltage (Drain)"*)
    parameter real BVD=BVS from[0.0:inf) ;
    (*units="A/m²", desc="Bottom junction reverse saturation current density (Source)"*)
    parameter real JSS=1.0e-4 from[0.0:inf) ;
    (*units="A/m²", desc="Bottom junction reverse saturation current density (Drain)"*)
    parameter real JSD=JSS from[0.0:inf) ;
    (*units="A/m", desc="Isolation-edge sidewall reverse saturation current density (Source)"*)
    parameter real JSWS=0.0 from[0.0:inf) ;
    (*units="A/m", desc="Isolation-edge sidewall reverse saturation current density (Drain)"*)
    parameter real JSWD=JSWS from[0.0:inf) ;

    (*units="A/m", desc="Gate-edge sidewall reverse saturation current density (Source)"*)
    parameter real JSWGS=0.0 from[0.0:inf) ;
    (*units="A/m", desc="Gate-edge sidewall reverse saturation current density (Drain)"*)
    parameter real JSWGD=JSWGS from[0.0:inf) ;
    (*units="A/m", desc="Bottom trap-assisted saturation current density (Source)"*)
    parameter real JTSS=0.0 from[0.0:inf) ;
    (*units="A/m", desc="Bottom trap-assisted saturation current density (Drain)"*)
    parameter real JTSD=JTSS from[0.0:inf) ;
    (*units="A/m²", desc="STI sidewall trap-assisted saturation current density (Source)"*)
    parameter real JTSSWS=0.0 from[0.0:inf) ;
    (*units="A/m²", desc="STI sidewall trap-assisted saturation current density (Drain)"*)
    parameter real JTSSWD=JTSSWS from[0.0:inf) ;
    (*units="A/m", desc="Gate-edge sidewall trap-assisted saturation current density (Source)"*)
    parameter real JTSSWGS=0.0 from[0.0:inf) ;
    (*units="A/m", desc="Gate-edge sidewall trap-assisted saturation current density (Drain)"*)
    parameter real JTSSWGD=JTSSWGS from[0.0:inf) ;
    (*units="", desc="Trap-assistant tunneling current density width dependence"*)
    parameter real JTWEFF=0.0 from[0.0:inf) ;
    (*units="", desc="Non-ideality factor for JTSS"*)
    parameter real NJTS=20.0 from[0.0:inf) ;
    (*units="", desc="Non-ideality factor for JTSD"*)
    parameter real NJTSD=NJTS from[0.0:inf) ;
    (*units="", desc="Non-ideality factor for JTSSW"*)
    parameter real NJTSSW=20.0 from[0.0:inf) ;
    (*units="", desc="Non-ideality factor for JTSSWD"*)
    parameter real NJTSSWD=NJTSSW from[0.0:inf) ;
    (*units="", desc="Non-ideality factor for JTSSWG"*)
    parameter real NJTSSWG=20.0 from[0.0:inf) ;
    (*units="", desc="Non-ideality factor for JTSSWDG"*)
    parameter real NJTSSWGD=NJTSSWG from[0.0:inf) ;

    (*units="", desc="Power dependence of JTSS on temperature"*)
    parameter real XTSS=0.02 from[0.0:inf) ;
    (*units="", desc="Power dependence of JTSD on temperature"*)
    parameter real XTSD=0.02 from[0.0:inf) ;
    (*units="", desc="Power dependence of JTSSWS on temperature"*)
    parameter real XTSSWS=0.02 from[0.0:inf) ;
    (*units="", desc="Power dependence of JTSSWD on temperature"*)
    parameter real XTSSWD=0.02 from[0.0:inf) ;
    (*units="", desc="Power dependence of JTSSWGS on temperature"*)
    parameter real XTSSWGS=0.02 from[0.0:inf) ;
    (*units="", desc="Power dependence of JTSSWGD on temperature"*)
    parameter real XTSSWGD=0.02 from[0.0:inf) ;
    (*units="V", desc="Bottom trap-assisted voltage dependent parameter (Source)"*)
    parameter real VTSS=10 from[0.0:inf) ;
    (*units="V", desc="Bottom trap-assisted voltage dependent parameter (Drain)"*)
    parameter real VTSD=VTSS from[0.0:inf) ;
    (*units="V", desc="STI sidewall trap-assisted voltage dependent parameter (Source)"*)
    parameter real VTSSWS=10 from[0.0:inf) ;
    (*units="V", desc="STI sidewall trap-assisted voltage dependent parameter (Drain)"*)
    parameter real VTSSWD=VTSSWS from[0.0:inf) ;
    (*units="V", desc="Gate-edge sidewall trap-assisted voltage dependent parameter (Source)"*)
    parameter real VTSSWGS=10 from[0.0:inf) ;
    (*units="V", desc="Gate-edge sidewall trap-assisted voltage dependent parameter (Drain)"*)
    parameter real VTSSWGD=VTSSWGS from[0.0:inf) ;
    (*units="", desc="Temperature coefficient for NJTS"*)
    parameter real TNJTS=0.0 from[0.0:inf) ;
    (*units="", desc="Temperature coefficient for NJTSD"*)
    parameter real TNJTSD=TNJTS from[0.0:inf) ;
    (*units="", desc="Temperature coefficient for NJTSSW"*)
    parameter real TNJTSSW=0.0 from[0.0:inf) ;
    (*units="", desc="Temperature coefficient for NJTSSWD"*)
    parameter real TNJTSSWD=TNJTSSW from[0.0:inf) ;
    (*units="", desc="Temperature coefficient for NJTSSWG"*)
    parameter real TNJTSSWG=0.0 from[0.0:inf) ;
    (*units="", desc="Temperature coefficient for NJTSSWGD"*)
    parameter real TNJTSSWGD=TNJTSSWG from[0.0:inf) ;

    (*units="F/m²", desc="Bottom junction capacitance per unit area at zero bias (Source)"*)
    parameter real CJS=5.0e-4 from[0.0:inf) ;
    (*units="F/m²", desc="Bottom junction capacitance per unit area at zero bias (Drain)"*)
    parameter real CJD=CJS from[0.0:inf) ;
    (*units="", desc="Bottom junction capacitance grating coefficient (Source)"*)
    parameter real MJS=0.5 from[0.0:0.99) ;
    (*units="", desc="Bottom junction capacitance grating coefficient (Drain)"*)
    parameter real MJD=MJS from[0.0:0.99) ;
    (*units="", desc="Isolation-edge sidewall junction capacitance grading coefficient (Source)"*)
    parameter real MJSWS=0.5 from[0.0:0.99) ;
    (*units="", desc="Isolation-edge sidewall junction capacitance grading coefficient (Drain)"*)
    parameter real MJSWD=MJSWS from[0.0:0.99) ;
    (*units="F/m", desc="Isolation-edge sidewall junction capacitance per unit area (Source)"*)
    parameter real CJSWS=5e-10 from[0.0:inf) ;
    (*units="F/m", desc="Isolation-edge sidewall junction capacitance per unit area (Drain)"*)
    parameter real CJSWD=CJSWS from[0.0:inf) ;
    (*units="F/m", desc="Gate-edge sidewall junction capacitance per unit length (Source)"*)
    parameter real CJSWGS=CJSWS from[0.0:inf) ;
    (*units="F/m", desc="Gate-edge sidewall junction capacitance per unit length (Drain)"*)
    parameter real CJSWGD=CJSWGS from[0.0:inf) ;
    (*units="", desc="Gate-edge sidewall junction capacitance grading coefficient (Source)"*)
    parameter real MJSWGS=MJSWS from[0.0:0.99) ;
    (*units="", desc="Gate-edge sidewall junction capacitance grading coefficient (Drain)"*)
    parameter real MJSWGD=MJSWGS from[0.0:0.99) ;
    (*units="V", desc="Bottom junction built-in potential (Source)"*)
    parameter real PBS=1.0 from[0.0:inf) ;
    (*units="V", desc="Bottom junction built-in potential (Drain)"*)
    parameter real PBD=PBS from[0.0:inf) ;
    (*units="V", desc="Isolation-edge sidewall junction built-in potential (Source)"*)
    parameter real PBSWS=1.0 from[0.0:inf) ;
    (*units="V", desc="Isolation-edge sidewall junction built-in potential (Drain)"*)
    parameter real PBSWD=PBSWS from[0.0:inf) ;
    (*units="V", desc="Gate-edge sidewall junction built-in potential (Source)"*)
    parameter real PBSWGS=PBSWS from[0.0:inf) ;
    (*units="V", desc="Gate-edge sidewall junction built-in potential (Drain)"*)
    parameter real PBSWGD=PBSWGS from[0.0:inf) ;

    // A.13 Temperature Dependence Parameters
    (*units="°C", desc="Temperature at which parameters are extracted"*)
    parameter real TNOM=27.0 from[-273.15:inf) ;
    (*units="", desc="Mobility temperature exponent"*)
    parameter real UTE=-1.5;
    parameter real LUTE = 0.0;
    parameter real WUTE = 0.0;
    parameter real PUTE = 0.0;
    (*units="", desc="Temperature coefficient of coulombic mobility"*)
    parameter real UCSTE=-4.775e-3;
    parameter real LUCSTE = 0.0;
    parameter real WUCSTE = 0.0;
    parameter real PUCSTE = 0.0;
    (*units="V", desc="Temperature coefficient for threshold voltage"*)
    parameter real KT1=-0.11;
    parameter real LKT1 = 0.0;
    parameter real WKT1 = 0.0;
    parameter real PKT1 = 0.0;
    (*units="Vm", desc="Channel length dependence of the temperature coefficient for threshold voltage"*)
    parameter real KT1L=0.0;
    parameter real LKT1L = 0.0;
    parameter real WKT1L = 0.0;
    parameter real PKT1L = 0.0;
    (*units="", desc="Body-bias coefficient of V th temperature effect"*)
    parameter real KT2=0.0;
    parameter real LKT2 = 0.0;
    parameter real WKT2 = 0.0;
    parameter real PKT2 = 0.0;
    (*units="m/V", desc="Temperature coefficient for UA"*)
    parameter real UA1=0.0;
    parameter real LUA1 = 0.0;
    parameter real WUA1 = 0.0;
    parameter real PUA1 = 0.0;
    (*units="(m/V)²", desc="Temperature coefficient for UB"*)
    parameter real UB1=0.0;
    parameter real LUB1 = 0.0;
    parameter real WUB1 = 0.0;
    parameter real PUB1 = 0.0;
    // TODO: mode dependent units (m/V^2) for MOBMOD=0,2
    (*units="V⁻¹", desc="Temperature coefficient for UC"*)
    parameter real UC1=0.0;
    parameter real LUC1 = 0.0;
    parameter real WUC1 = 0.0;
    parameter real PUC1 = 0.0;
    (*units="m⁻²", desc="Temperature coefficient for UD"*)
    parameter real UD1=0.0;
    parameter real LUD1 = 0.0;
    parameter real WUD1 = 0.0;
    parameter real PUD1 = 0.0;
    (*units="m/s", desc="Temperature coefficient for saturation velocity"*)
    parameter real AT=0.0;
    parameter real LAT = 0.0;
    parameter real WAT = 0.0;
    parameter real PAT = 0.0;
    (*units="Ω m", desc="Temperature coefficient for Rdsw"*)
    parameter real PRT=0.0;
    parameter real LPRT = 0.0;
    parameter real WPRT = 0.0;
    parameter real PPRT = 0.0;
    (*units="", desc="Emission coefficients of source junction"*)
    parameter real NJS=1.0 from[0.1:inf) ;
    (*units="", desc="Emission coefficients of drain junction"*)
    parameter real NJD=NJS from[0.1:inf) ;

    (*units="", desc="Junction current temperature exponents for source junction"*)
    parameter real XTIS=3.0;
    (*units="", desc="Junction current temperature exponents for drain junction"*)
    parameter real XTID=XTIS;
    (*units="V/K", desc="Temperature coefficient of PB"*)
    parameter real TPB=0.0;
    (*units="V/K", desc="Temperature coefficient of PBSW"*)
    parameter real TPBSW=0.0;
    (*units="V/K", desc="Temperature coefficient of PBSWG"*)
    parameter real TPBSWG=0.0;
    (*units="K⁻¹", desc="Temperature coefficient of CJ"*)
    parameter real TCJ=0.0;
    (*units="K⁻¹", desc="Temperature coefficient of CJSW"*)
    parameter real TCJSW=0.0;
    (*units="K⁻¹", desc="Temperature coefficient of CJSWG"*)
    parameter real TCJSWG=0.0;
    (*units="K⁻¹", desc="Temperature coefficient of VOFF"*)
    parameter real TVOFF=0.0;
    parameter real LTVOFF = 0.0;
    parameter real WTVOFF = 0.0;
    parameter real PTVOFF = 0.0;
    (*units="K⁻¹", desc="Temperature coefficient of VFBSDOFF"*)
    parameter real TVFBSDOFF=0.0;
    parameter real LTVFBSDOFF = 0.0;
    parameter real WTVFBSDOFF = 0.0;
    parameter real PTVFBSDOFF = 0.0;
    (*units="", desc="Temperature coefficient of NFACTOR"*)
    parameter real TNFACTOR=0.0;
    parameter real LTNFACTOR = 0.0;
    parameter real WTNFACTOR = 0.0;
    parameter real PTNFACTOR = 0.0;
    (*units="", desc="Temperature coefficient of ETA0"*)
    parameter real TETA0=0.0;
    parameter real LTETA0 = 0.0;
    parameter real WTETA0 = 0.0;
    parameter real PTETA0 = 0.0;
    (*units="K⁻¹", desc="Temperature coefficient of VOFFCV"*)
    parameter real TVOFFCV=0.0;
    parameter real LTVOFFCV = 0.0;
    parameter real WTVOFFCV = 0.0;
    parameter real PTVOFFCV = 0.0;

    // A.14 Stress Effect Model Parameters
    (*units="m", type="instance", desc="Distance between OD edge to Poly from one side"*)
    parameter real SA=0.0;
    (*units="m", type="instance", desc="Distance between OD edge to Poly from other side"*)
    parameter real SB=0.0;
    (*units="m", type="instance", desc="Distance between neighbouring fingers"*)
    parameter real SD=0.0;
    (*units="m", desc="Reference distance between OD and edge to poly of one side"*)
    parameter real SAREF=1e-6 from[0.0:inf) ;
    (*units="m", desc="Reference distance between OD and edge to poly of one side"*)
    parameter real SBREF=1e-6 from[0.0:inf) ;
    (*units="m", desc="Width parameter for stress effect"*)
    parameter real WLOD=0.0 from[0.0:inf) ;
    (*units="m", desc="Mobility degradation/enhancement coefficient for stress effect"*)
    parameter real KU0=0.0;
    (*units="m", desc="Saturation velocity degradation/ enhancement parameter for stress effect"*)
    parameter real KVSAT=0.0 from[-1.0:1.0] ;
    (*units="m", desc="Temperature coefficient of KU0"*)
    parameter real TKU0=0.0;

    (*units="", desc="Length dependence of KU0"*)
    parameter real LKU0=0.0;
    (*units="", desc="Width dependence of KU0"*)
    parameter real WKU0=0.0;
    (*units="", desc="Cross-term dependence of KU0"*)
    parameter real PKU0=0.0;
    (*units="", desc="Length parameter for u0 stress effect"*)
    parameter real LLODKU0=0.0 from[0.0:inf) ;
    (*units="Vm", desc="Width parameter for u0 stress effect"*)
    parameter real WLODKU0=0.0 from[0.0:inf) ;
    (*units="", desc="Threshold shift parameter for stress effect"*)
    parameter real KVTH0=0.0;
    (*units="", desc="Length dependence of KVTH0"*)
    parameter real LKVTH0=0.0;
    (*units="", desc="Width dependence of KVTH0"*)
    parameter real WKVTH0=0.0;
    (*units="", desc="Cross-term dependence of KVTH0"*)
    parameter real PKVTH0=0.0;
    (*units="", desc="Length parameter for Vth stress effect"*)
    parameter real LLODVTH=0.0 from[0.0:inf) ;
    (*units="", desc="Width parameter for Vth stress effect"*)
    parameter real WLODVTH=0.0 from[0.0:inf) ;
    (*units="m", desc="K2 shift factor related to Vth0 change"*)
    parameter real STK2=0.0;
    (*units="", desc="K2 shift modification factor for stress effect"*)
    parameter real LODK2=1.0 from[0.0:inf) ;
    (*units="m", desc="eta0 shift factor related to Vth0 change"*)
    parameter real STETA0=0.0;
    (*units="", desc="eta0 shift modification factor for stress effect"*)
    parameter real LODETA0=1.0 from[0.0:inf) ;

    // A.15 Well-Proximity Effect Model Parameters
    (*units="", type="instance", desc="Integral of the first distribution function for scattered well dopant"*)
    parameter real SCA=0.0 from[0.0:inf) ;
    (*units="", type="instance", desc="Integral of the second distribution function for scattered well dopant"*)
    parameter real SCB=0.0 from[0.0:inf) ;
    (*units="", type="instance", desc="Integral of the third distribution function for scattered well dopant"*)
    parameter real SCC=0.0 from[0.0:inf) ;
    (*units="m", type="instance", desc="Distance to a single well edge"*)
    parameter real SC=0.0;
    (*units="", desc="Coefficient for SCB"*)
    parameter real WEB=0.0 from[0.0:inf) ;
    (*units="", desc="Coefficient for SCC"*)
    parameter real WEC=0.0 from[0.0:inf) ;
    (*units="", desc="Threshold shift factor for well proximity effect"*)
    parameter real KVTH0WE=0.0 from[0.0:inf) ;
    parameter real LKVTH0WE = 0.0;
    parameter real WKVTH0WE = 0.0;
    parameter real PKVTH0WE = 0.0;
    (*units="", desc="K2 shift factor for well proximity effect"*)
    parameter real K2WE=0.0 from[0.0:inf) ;
    parameter real LK2WE = 0.0;
    parameter real WK2WE = 0.0;
    parameter real PK2WE = 0.0;
    (*units="", desc="Mobility degradation factor for well proximity effect"*)
    parameter real KU0WE=0.0 from[0.0:inf) ;
    parameter real LKU0WE = 0.0;
    parameter real WKU0WE = 0.0;
    parameter real PKU0WE = 0.0;
    (*units="m", desc="Reference distance to calculate SCA, SCB and SCC"*)
    parameter real SCREF=1e-6 from[0.0:inf) ;

    // A.16 dW and dL Parameters
    (*units="m^WLN", desc="Coefficient of length dependence for width offset"*)
    parameter real WL=0.0;
    (*units="", desc="Power of length dependence of width offset"*)
    parameter real WLN=1.0;
    (*units="m^WWN", desc="Coefficient of width dependence for width offset"*)
    parameter real WW=0.0;
    (*units="", desc="Power of width dependence of width offset"*)
    parameter real WWN=1.0;
    (*units="m^(WWN+WLN)", desc="Coefficient of length and width cross term dependence for width offset"*)
    parameter real WWL=0.0;
    (*units="m^LLN", desc="Coefficient of length dependence for length offset"*)
    parameter real LL=0.0;
    (*units="", desc="Power of length dependence of length offset"*)
    parameter real LLN=1.0;
    (*units="m^LWN", desc="Coefficient of width dependence for length offset"*)
    parameter real LW=0.0;
    (*units="", desc="Power of width dependence of length offset"*)
    parameter real LWN=1.0;
    (*units="m^(LWN+LLN)", desc="Coefficient of length and width cross term dependence for length offset"*)
    parameter real LWL=0.0;
    (*units="m^LLN", desc="Coefficient of length dependence for CV channel length offset"*)
    parameter real LLC=LL;
    (*units="m^LWN", desc="Coefficient of width dependence for CV channel length offset"*)
    parameter real LWC=LW;
    (*units="m^(LWN+LLN)", desc="Coefficient of length and width cross term dependence for CV channel length offset"*)
    parameter real LWLC=LWL;
    (*units="m^WWN", desc="Coefficient of length dependence for CV channel width offset"*)
    parameter real WLC=WL;
    (*units="m^(WLN)", desc="Coefficient of length dependence for CV channel width offset"*)
    parameter real WWC=WW;
    (*units="m^(WLN+WWN)", desc="Coefficient of length and width cross term dependence for CV channel width offset"*)
    parameter real WWLC=WWL;

    // A.17 Range Parameters for Model Application
    (*units="m", desc="Minimum channel length"*)
    parameter real LMIN=0.0 from[0.0:inf) ;
    (*units="m", desc="Maximum channel length"*)
    parameter real LMAX=1.0 from[0.0:inf) ;
    (*units="m", desc="Minimum channel length"*)
    parameter real WMIN=0.0 from[0.0:inf) ;
    (*units="m", desc="Maximum channel length"*)
    parameter real WMAX=1.0 from[0.0:inf) ;

    // Observables
    (* desc = "Gmb" *) real gmbs;
    (* desc = "Gm" *) real gmgs; // avoid conflict with gm node
    (* desc = "Gds" *) real gds;
    (* desc = "Vdsat" *) real vdsat;
    (* desc = "Vth" *) real vth;
    (* desc = "Ids" *) real id;
    (* desc = "Ibd" *) real ibd;
    (* desc = "Ibs" *) real ibs;
    (* desc = "gbd" *) real gbd;
    (* desc = "gbs" *) real gbs;
    (* desc = "Isub" *) real isub;
    (* desc = "Igidl" *) real igidl;
    (* desc = "Igisl" *) real igisl;
    (* desc = "Igs" *) real igs;
    (* desc = "Igd" *) real igd;
    (* desc = "Igb" *) real igb;
    (* desc = "Igcs" *) real igcs;
    (* desc = "Igcd" *) real igcd;
    (* desc = "Vbs" *) real vbs;
    (* desc = "Vgs" *) real vgs;
    (* desc = "Vds" *) real vds;
    (* desc = "Cggb" *) real cgg;
    (* desc = "Cgsb" *) real cgs;
    (* desc = "Cgdb" *) real cgd;
    (* desc = "Cbgb" *) real cbg;
    (* desc = "Cbdb" *) real cbd;
    (* desc = "Cbsb" *) real cbs;
    (* desc = "Cdgb" *) real cdg;
    (* desc = "Cddb" *) real cdd;
    (* desc = "Cdsb" *) real cds;
    (* desc = "Csgb" *) real csg;
    (* desc = "Csdb" *) real csd;
    (* desc = "Cssb" *) real css;
    (* desc = "Cgbb" *) real cgb;
    (* desc = "Cdbb" *) real cdb;
    (* desc = "Csbb" *) real csb;
    (* desc = "Cbbb" *) real cbb;
    (* desc = "Capbd" *) real capbd;
    (* desc = "Capbs" *) real capbs;
    (* desc = "Qgate" *) real qg;
    (* desc = "Qbulk" *) real qbulk;
    (* desc = "Qdrain" *) real qdrain;
    (* desc = "Qsource" *) real qsrc;
    (* desc = "Qinversion" *) real qinv;
    (* desc = "Qdef" *) real qdef;
    (* desc = "Gcrg" *) real gcrg;
    (* desc = "Gtau" *) real gtau;

    analog function real expclamp;
        input x;
        real x;

        begin
            // + 0 * x is for type stability on the julia side
            // TODO: Remove this
            if (x > `EXP_THRESHOLD)
                expclamp = `MAX_EXP + 0.0 * x;
            else if (x < -`EXP_THRESHOLD)
                expclamp = `MIN_EXP + 0.0 * x;
            else
                expclamp = exp(x);
        end
    endfunction

    analog function real clamp;
        input x, low, high;
        real x, low, high;

        if (x > high)
            clamp = high;
        else if (x < low)
            clamp = low;
        else
            clamp = x;
    endfunction


    analog function real expclamphigh;
        input x;
        real x;

        if (x > `EXP_THRESHOLD)
            expclamphigh = `MAX_EXP + 0.0 * x;
        else
            expclamphigh = exp(x);
    endfunction

    analog function real expclamplow;
        input x;
        real x;

        if (x < -`EXP_THRESHOLD)
            expclamplow = `MIN_EXP + 0.0 * x;
        else
            expclamplow = exp(x);
    endfunction

    analog function real expclamplow2;
        input a, b;
        real a, b;

        if (a > b / `EXP_THRESHOLD)
            expclamplow2 = exp(-b/a);
        else
            expclamplow2 = `MIN_EXP + 0.0 * b + 0.0 * a;
    endfunction

    analog function real exp_branches;
        input x, T0;
        real x, T0, T2;

        begin
            T2 = x / T0;
            if (T2 > `EXP_THRESHOLD)
                exp_branches = x;
            else if (T2 < -`EXP_THRESHOLD)
                exp_branches = T0 * ln(1.0 + `MIN_EXP + 0.0*x);
            else
                exp_branches = T0 * ln(1.0 + exp(T2));
        end
    endfunction

    analog function real qbsd_calc;
        input vbd_jct, cz, Phi, MJ;
        real vbd_jct, cz, Phi, MJ, arg, sarg;

        begin
            if (cz > 0.0) begin
                arg = 1.0 - vbd_jct / Phi;
                sarg = MJ == 0.5 ? 1.0 / sqrt(arg) : exp(-MJ * ln(arg));
                qbsd_calc = Phi * cz * (1.0 - arg * sarg) / (1.0 - MJ);
            end else
                qbsd_calc = 0.0;
        end
    endfunction

    // TODO: EXPL vs EXP. Audit this.
    analog function real lexp;
        input x;
        real x;

        begin
            if (x > `EXPL_THRESHOLD) begin
                lexp = `MAX_EXPL * (1.0 + x - `EXPL_THRESHOLD);
            end else if (x < -`EXPL_THRESHOLD) begin
                lexp = `MIN_EXPL + 0.0 * x;
            end else begin
                lexp = exp(x);
            end
        end
    endfunction

    analog function real lexpclamplow;
        input x;
        real x;

        if (x < -`EXPL_THRESHOLD)
            lexpclamplow = `MIN_EXPL + 0.0 * x;
        else
            lexpclamplow = exp(x);
    endfunction

    analog function real DEXP;
        input x;
        real x;
        begin
            if (x > `EXP_THRESHOLD) begin
                DEXP = `MAX_EXP * (1.0 + x - `EXP_THRESHOLD);
            end else if (x < -`EXP_THRESHOLD) begin
                DEXP = `MIN_EXP + 0.0 * x;
            end else begin
                DEXP = exp(x);
            end
        end
    endfunction

    analog function real vtmexp;
        input VTM0, vjct, njtemp, VTS;
        real VTM0, vjct, njtemp, VTS, Nvtm, T9, T0;

        begin
            Nvtm = VTM0 * njtemp;
            if ((VTS - vjct) < VTS * 1e-3) begin
                T9 = 1.0e3;
                T0 = - vjct / Nvtm * T9;
                vtmexp = lexp(T0);
            end else begin
                T9 = 1.0 / (VTS - vjct);
                T0 = - vjct / Nvtm * VTS * T9;
                vtmexp = lexp(T0);
            end
        end
    endfunction

    analog function real expoexpm1;
        input x;
        real x, T1, T2, T3, T4;

        begin
            if (x < `EXP_THRESHOLD) begin
                T1 = exp(x);
                T2 = T1 - 1.0;
                T3 = T2 * T2;
                T4 = T3 + 2.0 * T1 * `MIN_EXP;
                expoexpm1 = T1 / T4;
            end else begin
                expoexpm1 = 1.0 / (`MAX_EXP - 2.0) + 0.0 * x;
            end
        end
    endfunction

    analog function integer truncInt;
        input x;
        real x;

        truncInt = x > 0.0 ? floor(x) : ceil(x);
    endfunction

    analog function real Csqrt;
        input x;
        real x;

        Csqrt = x < -0.0 ? NaN : sqrt(x);
    endfunction

    analog function integer NumFingerDiff;
        input nf, minSD;
        output nuIntD, nuEndD, nuIntS, nuEndS;

        integer minSD;
        real nf, nuIntD, nuEndD, nuIntS, nuEndS;

        begin
            if ((truncInt(NF)%2) != 0) begin
                nuEndD = 1.0;
                nuEndS = 1.0;
                nuIntD = 2.0 * max((nf - 1.0) / 2.0, 0.0);
                nuIntS = nuIntD;
            end else begin
                if (minSD == 1) begin // minimize # of sources
                    nuEndD = 2.0;
                    nuIntD = 2.0 * max(nf/2.0 - 1.0, 0.0);
                    nuEndS = 0.0;
                    nuIntS = nf;
                end else begin
                    nuEndD = 0.0;
                    nuIntD = nf;
                    nuEndS = 2.0;
                    nuIntS = 2.0 * max(nf/2.0 - 1.0, 0.0);
                end
            end
        end
    endfunction

    analog function integer PAeffGEO;
        input nf, geo, minSD, Weffcj, DMCG, DMCI, DMDG;
        output Ps, Pd, As, Ad;

        integer geo, minSD;
        real nf, Weffcj, DMCG, DMCI, DMDG, Ps, Pd, As, Ad;

        real T0, T1, T2, PSiso, PDiso, PSsha, PDsha, PSmer, PDmer, ASiso, ADiso, ASsha, ADsha, ASmer, ADmer;

        real nuIntD;
        real nuEndD;
        real nuIntS;
        real nuEndS;
        integer NumFingerDiffDummy;

        begin
            nuIntD = 0.0;
            nuEndD = 0.0;
            nuIntS = 0.0;
            nuEndS = 0.0;
            if (geo < 9)
                NumFingerDiffDummy = NumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS);

            T0 = DMCG + DMCI;
            T1 = DMCG + DMCG;
            T2 = DMDG + DMDG;

            PSiso = T0 + T0 + Weffcj;
            PDiso = PSiso;
            PSsha = T1;
            PDsha = T1;
            PSmer = T2;
            PDmer = T2;

            ASiso = T0 * Weffcj;
            ADiso = T0 * Weffcj;

            ASsha = DMCG * Weffcj;
            ADsha = DMCG * Weffcj;

            ASmer = DMDG * Weffcj;
            ADmer = DMDG * Weffcj;

            case(geo)
                0: begin
                    Ps = nuEndS * PSiso + nuIntS * PSsha;
                    Pd = nuEndD * PDiso + nuIntD * PDsha;
                    As = nuEndS * ASiso + nuIntS * ASsha;
                    Ad = nuEndD * ADiso + nuIntD * ADsha;
                end
                1: begin
                    Ps = nuEndS * PSiso + nuIntS * PSsha;
                    Pd = (nuEndD + nuIntD) * PDsha;
                    As = nuEndS * ASiso + nuIntS * ASsha;
                    Ad = (nuEndD + nuIntD) * ADsha;
                end
                2: begin
                    Ps = (nuEndS + nuIntS) * PSsha;
                    Pd = nuEndD * PDiso + nuIntD * PDsha;
                    As = (nuEndS + nuIntS) * ASsha;
                    Ad = nuEndD * ADiso + nuIntD * ADsha;
                end
                3: begin
                    Ps = (nuEndS + nuIntS) * PSsha;
                    Pd = (nuEndD + nuIntD) * PDsha;
                    As = (nuEndS + nuIntS) * ASsha;
                    Ad = (nuEndD + nuIntD) * ADsha;
                end
                4: begin
                    Ps = nuEndS * PSiso + nuIntS * PSsha;
                    Pd = nuEndD * PDmer + nuIntD * PDsha;
                    As = nuEndS * ASiso + nuIntS * ASsha;
                    Ad = nuEndD * ADmer + nuIntD * ADsha;
                end
                5: begin
                    Ps = (nuEndS + nuIntS) * PSsha;
                    Pd = nuEndD * PDmer + nuIntD * PDsha;
                    As = (nuEndS + nuIntS) * ASsha;
                    Ad = nuEndD * ADmer + nuIntD * ADsha;
                end
                6: begin
                    Ps = nuEndS * PSmer + nuIntS * PSsha;
                    Pd = nuEndD * PDiso + nuIntD * PDsha;
                    As = nuEndS * ASmer + nuIntS * ASsha;
                    Ad = nuEndD * ADiso + nuIntD * ADsha;
                end
                7: begin
                    Ps = nuEndS * PSmer + nuIntS * PSsha;
                    Pd = (nuEndD + nuIntD) * PDsha;
                    As = nuEndS * ASmer + nuIntS * ASsha;
                    Ad = (nuEndD + nuIntD) * ADsha;
                end
                8: begin
                    Ps = nuEndS * PSmer + nuIntS * PSsha;
                    Pd = nuEndD * PDmer + nuIntD * PDsha;
                    As = nuEndS * ASmer + nuIntS * ASsha;
                    Ad = nuEndD * ADmer + nuIntD * ADsha;
                end
                9: begin /* geo = 9 and 10 happen only when nf = even */
                    Ps = PSiso + (nf - 1.0) * PSsha;
                    Pd = nf * PDsha;
                    As = ASiso + (nf - 1.0) * ASsha;
                    Ad = nf * ADsha;
                end
                10: begin
                    Ps = nf * PSsha;
                    Pd = PDiso + (nf - 1.0) * PDsha;
                    As = nf * ASsha;
                    Ad = ADiso + (nf - 1.0) * ADsha;
                end
                default: $warning("Warning: Specified GEO = ", geo, " not matched");
            endcase
        end
    endfunction


    analog function real RdsEndIso;
        input Weffcj, Rsh, DMCG, DMCI, DMDG;
        input nuEnd, rgeo, Type;

        real Weffcj, Rsh, DMCG, DMCI, DMDG;
        integer rgeo, Type;
        real nuEnd;

        begin
            if (Type == 1) begin
                if (rgeo == 1 || rgeo == 2 || rgeo == 5) begin
                    if (nuEnd == 0.0)
                        RdsEndIso = 0.0;
                    else
                        RdsEndIso = Rsh * DMCG / (Weffcj * nuEnd);
                end else if (rgeo == 3 || rgeo == 4 || rgeo == 6) begin
                    if ((DMCG + DMCI) == 0.0)
                        $strobe("(DMCG + DMCI) can not be equal to zero\n");
                    if ((nuEnd == 0.0)||((DMCG+DMCI)==0.0))
                        RdsEndIso = 0.0;
                    else
                        RdsEndIso = Rsh * Weffcj / (3.0 * nuEnd * (DMCG + DMCI));
                end else
                    $strobe("Warning: Specified RGEO = %d not matched\n", rgeo);
            end else begin
                if(rgeo == 1 || rgeo == 3 || rgeo == 7) begin
                    if (nuEnd == 0.0)
                        RdsEndIso = 0.0;
                    else
                        RdsEndIso = Rsh * DMCG / (Weffcj * nuEnd);
                end else if (rgeo == 2 || rgeo == 4 || rgeo == 8) begin
                    if ((DMCG + DMCI) == 0.0)
                        $strobe("(DMCG + DMCI) can not be equal to zero\n");
                    if ((nuEnd == 0.0)||((DMCG + DMCI)==0.0))
                        RdsEndIso = 0.0;
                    else
                        RdsEndIso = Rsh * Weffcj / (3.0 * nuEnd * (DMCG + DMCI));
                end else
                    $strobe("Warning: Specified RGEO = %d not matched\n", rgeo);
            end
        end
    endfunction

    analog function real RdsEndSha;
        input Weffcj, Rsh, DMCG, DMCI, DMDG;
        input nuEnd, rgeo, Type;

        real Weffcj, Rsh, DMCG, DMCI, DMDG;
        integer rgeo, Type;
        real nuEnd;

        begin
            if (Type == 1) begin
                if(rgeo == 1 || rgeo == 2 || rgeo == 5) begin
                    if (nuEnd == 0.0)
                        RdsEndSha = 0.0;
                    else
                        RdsEndSha = Rsh * DMCG / (Weffcj * nuEnd);
                end else if (rgeo == 3 || rgeo == 4 || rgeo == 6) begin
                    if (DMCG == 0.0)
                        $strobe("DMCG can not be equal to zero\n");
                    if (nuEnd == 0.0)
                        RdsEndSha = 0.0;
                    else
                        RdsEndSha = Rsh * Weffcj / (6.0 * nuEnd * DMCG);
                end else
                    $strobe("Warning: Specified RGEO = %d not matched\n", rgeo);
            end else begin
                if(rgeo == 1 || rgeo == 3 || rgeo == 7) begin
                    if (nuEnd == 0.0)
                        RdsEndSha = 0.0;
                    else
                        RdsEndSha = Rsh * DMCG / (Weffcj * nuEnd);
                    end
                else if (rgeo == 2 || rgeo == 4 || rgeo == 8) begin
                    if (DMCG == 0.0)
                        $strobe("(DMCG + DMCI) can not be equal to zero\n");
                    if (nuEnd == 0.0)
                        RdsEndSha = 0.0;
                    else
                        RdsEndSha = Rsh * Weffcj / (6.0 * nuEnd * DMCG);
                end else
                    $strobe("Warning: Specified RGEO = %d not matched\n", rgeo);
            end
        end
    endfunction

    analog function real RdseffGeo;
        input geo, rgeo, minSD, Type;
        input nf, Weffcj, Rsh, DMCG, DMCI, DMDG;
        integer geo, rgeo, minSD, Type;
        real nf, Weffcj, Rsh, DMCG, DMCI, DMDG;

        real Rint  ;
        real Rend  ;
        real nuIntD;
        real nuEndD;
        real nuIntS;
        real nuEndS;

        integer dummy;

        begin
            if (geo < 9) begin
                dummy = NumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS);
            end

            if (Type == 1) begin
                if (nuIntS == 0.0)
                    Rint = 0.0;
                else
                    Rint = Rsh * DMCG / ( Weffcj * nuIntS);
            end else begin
                if (nuIntD == 0.0)
                    Rint = 0.0;
                else
                    Rint = Rsh * DMCG / ( Weffcj * nuIntD);
            end


            /* End S/D resistance  -- geo dependent */
            case(geo)
                0: begin
                    if (Type == 1)
                        Rend = RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, rgeo, 1);
                    else
                        Rend = RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, rgeo, 0);
                end
                1: begin
                    if (Type == 1)
                        Rend = RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, rgeo, 1);
                    else
                        Rend = RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, rgeo, 0);
                end
                2: begin
                    if (Type == 1)
                        Rend = RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, rgeo, 1);
                    else
                        Rend = RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, rgeo, 0);
                end
                3: begin
                    if (Type == 1)
                        Rend = RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, rgeo, 1);
                    else
                        Rend = RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, rgeo, 0);
                end
                4: begin
                    if (Type == 1)
                        Rend = RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, rgeo, 1);
                    else
                        Rend = Rsh * DMDG / Weffcj;
                end
                5: begin
                    if (Type == 1)
                        Rend = RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, rgeo, 1);
                    else
                        Rend = Rsh * DMDG / (Weffcj * nuEndD);
                end
                6: begin
                    if (Type == 1)
                        Rend = Rsh * DMDG / Weffcj;
                    else
                        Rend = RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, rgeo, 0);
                end
                7: begin
                    if (Type == 1)
                        Rend = Rsh * DMDG / (Weffcj * nuEndS);
                    else
                        Rend = RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, rgeo, 0);
                end
                8: begin
                    Rend = Rsh * DMDG / Weffcj;
                end
                9: begin /* all wide contacts assumed for geo = 9 and 10 */
                    if (Type == 1) begin
                        Rend = 0.5 * Rsh * DMCG / Weffcj;
                        if (nf == 2.0)
                            Rint = 0.0;
                        else
                            Rint = Rsh * DMCG / (Weffcj * (nf - 2.0));
                    end else begin
                        Rend = 0.0;
                        Rint = Rsh * DMCG / (Weffcj * nf);
                    end
                end
                10: begin
                    if (Type == 1) begin
                    Rend = 0.0;
                        Rint = Rsh * DMCG / (Weffcj * nf);
                    end else begin
                        Rend = 0.5 * Rsh * DMCG / Weffcj;
                        if (nf == 2.0)
                            Rint = 0.0;
                        else
                            Rint = Rsh * DMCG / (Weffcj * (nf - 2.0));
                    end
                end
                default:
                    $strobe("Warning: Specified GEO = %d not matched\n", geo);
            endcase

            if (Rint <= 0.0)
                RdseffGeo = Rend;
            else if (Rend <= 0.0)
                RdseffGeo = Rint;
            else
                RdseffGeo = Rint * Rend / (Rint + Rend);
            if(RdseffGeo==0.0)
                $strobe("Warning: Zero resistance returned from RdseffGeo\n");
        end
    endfunction

    analog function real Eval1ovFNoise;
        input Vds, leff, weff, vsattemp, Vdseff, Vgsteff, litl, cd, ueff, Abulk, coxe, AbovVgst2Vtm, temp, em, nf, lintno, tnoia, tnoib, tnoic, nstar;
        real Vds, leff, weff, vsattemp, Vdseff, Vgsteff, litl, cd, ueff, Abulk, coxe, AbovVgst2Vtm, temp, em, nf, lintno, tnoia, tnoib, tnoic, nstar;

        real Leff, LeffSq, esat, N0, Nl, DelClm, EffFreq;
        real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9;

        begin
            Leff = leff - 2.0 * lintno;
            LeffSq = Leff * Leff;
            esat = 2.0 * vsattemp / ueff;
            if (em <= 0.0) DelClm = 0.0;
            else begin
                T0 = ((Vds - Vdseff) / litl + em) / esat;
                DelClm = litl * ln(max(T0, `N_MINLOG));
                if (DelClm < 0.0) DelClm = 0.0;
            end
            EffFreq = 1.0; // Multiplied in later by $flicker_noise
            T1 = `P_Q * `P_Q * `P_K * cd * temp * ueff;
            T2 = 1.0e10 * EffFreq * Abulk * coxe * LeffSq;
            N0 = coxe * Vgsteff / `P_Q;
            Nl = coxe * Vgsteff * (1.0 - AbovVgst2Vtm * Vdseff) / `P_Q;

            T3 = tnoia * ln(max((N0 + nstar)/(Nl + nstar), `N_MINLOG));
            T4 = tnoib * (N0 - Nl);
            T5 = tnoic * 0.5 * (N0 * N0 - Nl * Nl);

            T6 = `P_Q * temp * cd * cd;
            T7 = 1.0e10 * EffFreq * LeffSq * weff * nf;
            T8 = tnoia + tnoib * Nl + tnoic * Nl * Nl;
            T9 = (Nl + nstar) * (Nl + nstar);
            Eval1ovFNoise = T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;
        end
    endfunction

    analog function real BSIM4polyDepletion;
        input phi, ngate, epsgate, coxe, Vgs;
        real phi, ngate, epsgate, coxe, Vgs;

        real T1, T2, T3, T4, T5, T6, T7, T8;

        if ((ngate > 1.0e18) &&
            (ngate < 1.0e25) && (Vgs > phi) && (epsgate!=0)) begin
            T1 = 1.0e6 * `P_Q * epsgate * ngate / (coxe * coxe);
            T8 = Vgs - phi;
            T4 = sqrt(1.0 + 2.0 * T8 / T1);
            T2 = 2.0 * T8 / (T4 + 1.0);
            T3 = 0.5 * T2 * T2 / T1; // T3 = Vpoly
            T7 = 1.12 - T3 - 0.05;
            T6 = sqrt(T7 * T7 + 0.224);
            T5 = 1.12 - 0.5 * (T7 + T6);
            BSIM4polyDepletion = Vgs - T5;
        end else
            BSIM4polyDepletion = Vgs;
    endfunction

    analog function real DioIjthVjmEval;
        real Nvtm, Ijth, Isb, XExpBV;
        input Nvtm, Ijth, Isb, XExpBV;

        real Tc, Tb, EVjmovNv;

        begin
            Tc = XExpBV;
            Tb = 1.0 + Ijth / Isb - Tc;
            EVjmovNv = 0.5 * (Tb + sqrt(Tb * Tb + 4.0 * Tc));
            DioIjthVjmEval = Nvtm * ln(EVjmovNv);
        end
    endfunction

    analog function real bound_grb;
        input gbmin, rb;
        real gbmin, rb;

        if (rb < 1.0e-3)
            bound_grb = 1.0e3;
        else
            bound_grb = gbmin + 1.0 / rb;
    endfunction

    // Intermediate variables
    integer i;
    real Temp, epsrox, epssub, coxe, coxp, TRatio, vcrit, factor1, vtm, Eg0, ni,
        Vtm0, Eg, delTemp, PhiBS, PhiBD, PhiBSWS, PhiBSWD, PhiBSWGS, PhiBSWGD, Ldrn, Wdrn,
        Length, Width, Lnew, Wnew, n0, tmp1, dl, dlc, dw, dwc, dwj, leff, leffCV, weffCV,
        weffCJ, Inv_L, Inv_W, Inv_LW, abulkCVfactor, clc, PowWeffWr, rds0, rdswmin, rdwmin, rs0,
        rswmin, u0temp, phi, sqrtPhi, phis3, Xdep0, sqrtXdep0, litl, vbi, vfbsd, cdep0, ToxRatio,
        ToxRatioEdge, Aechvb, Bechvb, AechvbEdgeS, AechvbEdgeD, BechvbEdge, mstar, mstarcv,
        voffcbn, voffcbncv, ldeb, k1ox, tmp, theta0vb0, thetaRout, vfbzbfactor, wlod, W_tmp,
        kstress_u0, kvth0, ku0temp, Inv_saref, Inv_sbref, inv_od_ref, rho_ref, dvtp2factor, vtfbphi1, vtfbphi2,
        vbsc, k2ox, vfbzb, lnl, lnw, lnnf, grgeltd, DMCGeff, DMCIeff, DMDGeff,
        PSeff, PDeff, ASeff, ADeff, sourceConductance, drainConductance,
        SourceSatCurrent, DrainSatCurrent, Nvtms, Nvtmd, njtsstemp, njtsswstemp, njtsswgstemp, njtsdtemp,
        njtsswdtemp, njtsswgdtemp, vges, vgms, vdbs, vsbs, vses, vdes, vbd, vgb, vgd,
        vged, vgmd, vgmb, vdbd, vbs_jct, vbd_jct, vjct, sigvds, Vds, Vgs, Vbs, Vdb, Vbseff,
        Phis, sqrtPhis, Xdep, V0, lt1, ltw, Theta0, Delt_vth,
        thetavth, TempRatio, Vth_NarrowW, DIBL_sft, Lpe_Vb, Vth, von, nstar, n, DITS_Sft2,
        vgs_eff, vgd_eff, Vgs_eff, Vgst, Vgsteff, Rds, Abulk0, Abulk, Denomi, ueff,
        WVCox, WVCoxRds, Esat, EsatL, Lambda, Vgst2Vtm, Vdsat, Vdseff, diffVds,
        Vasat, Tcen, Coxeff, CoxeffWovL, beta, AbovVgst2Vtm, fgche1, fgche2, gche,
        Idl, FP, PvagTerm, Cclm, VACLM, VADIBL, Va, VADITS, VASCBE, Idsa, ISub, Ids,
        cdrain, IdovVds, Igidl, VbseffCV, CoxWL, V3, Vfb, Vfbeff, Voxacc, Cox, Tox, LINK,
        V4, Ccen, CoxWLcen, Qac0, Qsub0, QovCox, DeltaPhi, VgDP, AbulkCV, VdsatCV,
        VdseffCV, czbd, czbs, czbdsw, czbdswg, czbssw, czbsswg, vgdx, vgsx, npart_beta,
        npart_theta, gspr, gdpr, grbdb, grbpb, grbps, grbsb, grbpd, igsquare, Ssi, Swi,
        vjSmFwd, IvjSmFwd, vjDmFwd, IvjDmFwd, XExpBVD, XExpBVS, tfactor, vs, Fsevl, Voxdepinv, VxNVt, Vaux,
        Pigcd, grdsw, eta, gamma, epsilon, omega, Lvsat, npart_c, ctnoi, GammaGd0, noiGd0, C0, sigrat,
        SjctTempRevSatCur, DjctTempRevSatCur, SswTempRevSatCur, DswTempRevSatCur, SswgTempRevSatCur,
        DswgTempRevSatCur,
        SjctTempSatCurDensity, SjctSidewallTempSatCurDensity, SjctGateSidewallTempSatCurDensity,
        DjctTempSatCurDensity, DjctSidewallTempSatCurDensity, DjctGateSidewallTempSatCurDensity,
        SunitAreaTempJctCap, SunitLengthSidewallTempJctCap, SunitLengthGateSidewallTempJctCap,
        DunitAreaTempJctCap, DunitLengthSidewallTempJctCap, DunitLengthGateSidewallTempJctCap;

    // N.B.: These are not the same. Weff is C's `Weff`, weff is BSIM4weff.
    real weff, Weff;

    real qgate, qdrn, qcheq, qbs, qbd, qgdo, qgso, qgmb, qgmid,
        qgb, qbody, qd, qs, qb, gstot, gdtot;

    real cqgate, cqbody, cqdrn, ceqqg, ceqqd, ceqqb, ceqdrn, ceqbd, ceqbs,
        ceqqgmid, csub, Igisl, ceqjs, ceqjd, Igc, Igs, Igd, Igcs, Igcd, Igb,
        Igbacc, Igbinv,
        ceqqjs, ceqqjd, ceqgstot, ceqgcrg;

    real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
        tmp2, tmp3, tmp4;

    // Size adjusted versions of the parameters
    real cdsc, cdscb, cdscd, cit, nfactor, tnfactor, xj, vsat, at, a0, ags, a1, a2, keta, nsub,
         ndep, nsd, phin, ngate, gamma1, gamma2, vbx, vbm, xt, vfb, k1, kt1, kt1l, kt2, k2, k3, k3b,
         w0, lpe0, lpeb, dvtp0, dvtp1, dvtp2, dvtp3, dvtp4, dvtp5, dvt0, dvt1, dvt2, dvt0w,
         dvt1w, dvt2w, drout, dsub, vth0, ua, ua1, ub, ub1, uc, uc1, ud, ud1, up, lp, u0,
         ute, ucs, ucste, voff, tvoff, minv, minvcv, fprout, pdits, pditsd, delta, rdsw, rd0,
         rdw, rsw, prwg, prwb, prt, eta0, teta0, tvoffcv, etab, pclm, pdibl1, pdibl2,
         pdiblb, pscbe1, pscbe2, pvag, wr, dwg, dwb, b0, b1, alpha0, alpha1, beta0, agidl,
         bgidl, cgidl, egidl, rgidl, kgidl, fgidl, agisl, bgisl, cgisl, egisl, rgisl, kgisl,
         fgisl, aigc, bigc, cigc, aigsd, bigsd, cigsd, aigbacc, bigbacc, cigbacc, aigbinv, bigbinv,
         cigbinv, nigc, nigbacc, nigbinv, ntox, eigbinv, pigcd, poxedge, xrcrg1, xrcrg2, lambda,
         vtl, xn, vfbsdoff, tvfbsdoff, cgsl, cgdl, ckappas, ckappad, cle, vfbcv, acde, moin, noff,
         voffcv, kvth0we, k2we, ku0we, vsattemp, sceff,
         vjSmRev, IvjSmRev, SslpFwd, SslpRev, svjDmRev, IvjDmRev, DslpFwd, DslpRev;
    // Celsius temperature parameters adjusted to Kelvin
    // The C code does this on parameter get/set. The parameter
    // is specified in Celsius, but the code uses Kelvin.
    real tnom, tempeot;
    // Processed / bounded parameters (might be reset to a default value, overridden, or clamped)
    real scref, rbsb, rbdb, rbps, rbpd, rbpb, toxp, toxe, toxm, eot, dlcig, dlcigd, cf, aigd, aigs,
         cigd, cigs, bigd, bigs, cgso, cgdo, cgbo, kvsat, sca, scb, scc, l, w, pd, ps, ad, as;

    // TODO: Use initializers for this once our parser understands them
    //real scref = SCREF, rbsb = RBSB, rbdb = RBDB, rbps = RBPS, rbpd = RBPD, rbpb = RBPB,
    //     toxp = TOXP, toxe = TOXE, toxm = TOXM, eot = EOT, dlcig = DLCIG, dlcigd = DLCIGD,
    //     cf = CF, aigd = AIGD, aigs = AIGS, cigd = CIGD, cigs = CIGS, bigd = BIGD, bigs = BIGS,
    //     cgso = CGSO, cgdo = CGDO, cgbo = CGBO, kvsat = KVSAT, sca = SCA, scb = SCB, scc = SCC,
    //     l = L, w = W, pd = PD, ps = PS, ad = AD, as = AS;

    real eu;
    real Leff;
    integer bodymode, createSourceNode, createDrainNode;
    integer dummy;

    analog begin
        tnom = TNOM + 273.15;
        tempeot = TEMPEOT + 273.15;

        scref = SCREF;
        rbsb = RBSB;
        rbdb = RBDB;
        rbps = RBPS;
        rbpd = RBPD;
        rbpb = RBPB;
        toxp = TOXP;
        toxe = TOXE;
        toxm = TOXM;
        eot = EOT;
        dlcig = DLCIG;
        dlcigd = DLCIGD;
        cf = CF;
        aigd = AIGD;
        aigs = AIGS;
        cigd = CIGD;
        cigs = CIGS;
        bigd = BIGD;
        bigs = BIGS;
        cgso = CGSO;
        cgdo = CGDO;
        cgbo = CGBO;
        kvsat = KVSAT;
        sca = SCA;
        scb = SCB;
        scc = SCC;

        // ************************************************
        // *      Geometry dependent calculations         *
        // ************************************************
        begin : B4BiasIndepCalc
            // Apply scale parameter, per b4par:49
            l = L * `SIMPARSCAL;
            w = W * `SIMPARSCAL;
            pd = PD * `SIMPARSCAL;
            ps = PS * `SIMPARSCAL;
            as = AS * `SIMPARSCAL*`SIMPARSCAL;
            ad = AD * `SIMPARSCAL*`SIMPARSCAL;

            // b4v7set:509
            if ($param_given(AIGSD)) begin
                aigd = AIGSD;
                aigs = AIGSD;
            end
            if ($param_given(BIGSD)) begin
                bigd = BIGSD;
                bigs = BIGSD;
            end
            if ($param_given(CIGSD)) begin
                cigd = CIGSD;
                cigs = CIGSD;
            end
            Temp = $temperature;

            if (MTRLMOD == 0) begin
                if ($param_given(TOXE) && $param_given(TOXP) && $param_given(DTOX) &&
                        TOXE != TOXP + DTOX)
                    $warning("Warning: toxe, toxp and dtox all given and toxe != toxp + dtox; dtox ignored");
                else if ($param_given(TOXE) && !$param_given(TOXP))
                    toxp = toxe - DTOX;
                else if (!$param_given(TOXE) && $param_given(TOXP)) begin
                    toxe = TOXP + DTOX;
                    if (!$param_given(TOXM)) // 4.7
                        toxm = toxe;
                end
                if (!$param_given(CF)) begin
                    cf = 2.0 * EPSROX * `EPS0 / `M_PI *
                         ln(1.0 + 0.4e-6 / toxe);
                end
            end else if (MTRLCOMPATMOD != 0) begin
                T0 = EPSROX / 3.9;
                if ($param_given(EOT) && $param_given(TOXP) && $param_given(DTOX) &&
                        abs(eot * T0 - (TOXP + DTOX)) > 1e-20)
                    $warning("Warning: eot, toxp and dtox all given and eot * EPSROX / 3.9 != toxp + dtox; dtox ignored.");
                else if ($param_given(EOT) && !$param_given(TOXP))
                    toxp = T0 * eot - DTOX;
                else if (!$param_given(EOT) && $param_given(TOXP)) begin
                    eot = (TOXP + DTOX) / T0;
                    if (!$param_given(TOXM))
                        toxm = eot;
                end
            end

            if (MTRLMOD != 0) begin
                epsrox = 3.9;
                toxe = eot;
                epssub = `EPS0 * EPSRSUB;
            end else begin
                epsrox = EPSROX;
                epssub = `EPSSI;
            end

            coxe = epsrox * `EPS0 / toxe;
            if (MTRLMOD == 0 || MTRLCOMPATMOD != 0)
                coxp = EPSROX * `EPS0 / toxp; // should coxp be upper?

            if (!$param_given(CGDO))
                if ($param_given(DLC) && DLC > 0.0)
                    cgdo = DLC * coxe - CGDL;
                else
                    cgdo = 0.6 * XJ * coxe;

            if (!$param_given(CGSO))
                if ($param_given(DLC) && DLC > 0.0)
                    cgso = DLC * coxe - CGSL;
                else
                    cgso = 0.6 * XJ * coxe;

            if (!$param_given(CGBO))
                cgbo = 2.0 * DWC * coxe;
            // TODO: skipping pLastKnot (???)

            TRatio = $temperature / tnom;
            vcrit = `CONSTvt0 * ln(`CONSTvt0 / (sqrt(2.) * 1.0e-14));
            factor1 = sqrt(epssub / (epsrox * `EPS0) * toxe);
            Vtm0 = `KboQ * tnom;

            if (MTRLMOD == 0) begin
                Eg0 = 1.16 - 7.02e-4 * tnom * tnom / (tnom + 1108.0);
                ni = 1.45e10 * (tnom / 300.15) * sqrt(tnom / 300.15)
                 * exp(21.5565981 - Eg0 / (2.0 * Vtm0));
            end else begin
                Eg0 = BG0SUB - TBGASUB * tnom * tnom / (tnom + TBGBSUB);
                T0 = BG0SUB - TBGASUB * 90090.0225 / (300.15 + TBGBSUB);
                ni = NI0SUB * (tnom / 300.15) * sqrt(tnom / 300.15) *
                    exp((T0 - Eg0) / (2.0 * Vtm0));
            end

            vtm = `KboQ * Temp;
            if (MTRLMOD == 0)
                Eg = 1.16 - 7.02e-4 * Temp * Temp / (Temp + 1108.0);
            else
                Eg = BG0SUB - TBGASUB * Temp * Temp / (Temp + TBGBSUB);

            if (Temp != tnom) begin
                T0 = Eg0 / Vtm0 - Eg/vtm;
                T1 = ln(Temp / tnom);
                T2 = T0 + XTIS * T1;
                T3 = exp(T2 / NJS);
                SjctTempSatCurDensity = JSS * T3;
                SjctSidewallTempSatCurDensity = JSWS * T3;
                SjctGateSidewallTempSatCurDensity = JSWGS * T3;

                T2 = T0 + XTID * T1;
                T3 = exp(T2 / NJD);
                DjctTempSatCurDensity = JSD * T3;
                DjctSidewallTempSatCurDensity = JSWD * T3;
                DjctGateSidewallTempSatCurDensity = JSWGD * T3;
            end else begin
                SjctTempSatCurDensity = JSS;
                SjctSidewallTempSatCurDensity = JSWS;
                SjctGateSidewallTempSatCurDensity = JSWGS;
                DjctTempSatCurDensity = JSD;
                DjctSidewallTempSatCurDensity = JSWD;
                DjctGateSidewallTempSatCurDensity = JSWGD;
            end

            if (SjctTempSatCurDensity < 0.0)
                SjctTempSatCurDensity = 0.0;
            if (SjctSidewallTempSatCurDensity < 0.0)
                SjctSidewallTempSatCurDensity = 0.0;
            if (SjctGateSidewallTempSatCurDensity < 0.0)
                SjctGateSidewallTempSatCurDensity = 0.0;
            if (DjctTempSatCurDensity < 0.0)
                DjctTempSatCurDensity = 0.0;
            if (DjctSidewallTempSatCurDensity < 0.0)
                DjctSidewallTempSatCurDensity = 0.0;
            if (DjctGateSidewallTempSatCurDensity < 0.0)
                DjctGateSidewallTempSatCurDensity = 0.0;
            delTemp = Temp - tnom;
            T0 = TCJ * delTemp;
            if (T0 >= -1.0) begin
                SunitAreaTempJctCap = CJS * (1.0 + T0);
                DunitAreaTempJctCap = CJD * (1.0 + T0);
            end else begin
                if (CJS > 0.0) begin
                    SunitAreaTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjs to be negative. Cjs is clamped to zero.");
                end
                if (CJD > 0.0) begin
                    DunitAreaTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjd to be negative. Cjd is clamped to zero.");
                end
            end

            T0 = TCJSW * delTemp;
            // CJSWS/D clamping handled in parameter def
            if (T0 >= -1.0) begin
                SunitLengthSidewallTempJctCap = CJSWS * (1.0 + T0);
                DunitLengthSidewallTempJctCap = CJSWD * (1.0 + T0);
            end else begin
                if (CJSWS > 0.0) begin
                    SunitLengthSidewallTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjsws to be negative. Cjsws is clamped to zero.");
                end
                if (CJSWD > 0.0) begin
                    DunitLengthSidewallTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjswd to be negative. Cjswd is clamped to zero.");
                end
            end

            T0 = TCJSWG * delTemp;
            if (T0 >= -1.0) begin
                SunitLengthGateSidewallTempJctCap = CJSWGS * (1.0 + T0);
                DunitLengthGateSidewallTempJctCap = CJSWGD * (1.0 + T0);
            end else begin
                if (CJSWGS > 0.0) begin
                    SunitLengthGateSidewallTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjswgs to be negative. Cjswgs is clamped to zero.");
                end
                if (CJSWGD > 0.0) begin
                    DunitLengthGateSidewallTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjswgd to be negative. Cjswgd is clamped to zero.");
                end
            end

            `define tempclamp(var, PB, TPB, name) begin \
                if (PB < 0.1) begin \
                    $strobe("Given `", name, "` is less than 0.1. `", name, "` is set to 0.1."); \
                    var = 0.1 - TPB * delTemp; \
                end else begin \
                    var = PB - TPB * delTemp; \
                end \
                if (var < 0.01) begin \
                    var = 0.01; \
                    $strobe("Temperature effect has caused ", name, " to be less than 0.01. `", name, "` is clamped to 0.01."); \
                end \
            end

            `tempclamp(PhiBS, PBS, TPB, "pbs")
            `tempclamp(PhiBD, PBD, TPB, "pbd")
            `tempclamp(PhiBSWS, PBSWS, TPBSW, "pbsws")
            `tempclamp(PhiBSWD, PBSWD, TPBSW, "pbswd")
            `tempclamp(PhiBSWGS, PBSWGS, TPBSWG, "pbswgs")
            `tempclamp(PhiBSWGD, PBSWGD, TPBSWG, "pbswgd")

            // End of junction capacitance

            // N.B. 0 clamping of threshold parameters handled in parameter def
            // TODO Skipped C code from 425 to 442
            Ldrn = l;
            Wdrn = w / NF;

            begin : SizeDepCalc
                // Length = L;
                // Width = W;
                // NFinger = NF;
                Lnew = l + XL;
                Wnew = w / NF + XW;

                T0 = pow(Lnew, LLN);
                T1 = pow(Wnew, LWN);

                tmp1 = LL / T0 + LW / T1 + LWL / (T0 * T1);
                dl = LINT + tmp1;

                tmp2 = LLC / T0 + LWC / T1 + LWLC / (T0 * T1);
                dlc = DLC + tmp2;

                T2 = pow(Lnew, WLN);
                T3 = pow(Wnew, WWN);
                tmp1 = WL / T2 + WW / T3 + WWL / (T2 * T3);
                dw = WINT + tmp1;
                tmp2 = WLC / T2 + WWC / T3 + WWLC / (T2 * T3);
                dwc = DWC + tmp2;
                dwj = DWJ + tmp2;

                leff = Lnew - 2.0 * dl;
                if (leff <= 0.0)
                    $error("BSIM4: Effective channel length <= 0");

                weff = Wnew - 2.0 * dw;
                if (weff <= 0.0)
                    $error("BSIM4: Effective channel width <= 0");

                leffCV = Lnew - 2.0 * dlc;
                if (leffCV <= 0.0)
                    $error("BSIM4: Effective channel length for C-V < 0");

                weffCV = Wnew - 2.0 * dwc;
                if (weffCV <= 0.0)
                    $error("BSIM4: Effective channel width for C-V < 0");

                weffCJ = Wnew - 2.0 * dwj;
                if (weffCJ <= 0.0)
                    $error("BSIM4: Effective channel width for S/D junctions < 0");

                if (BINUNIT == 1) begin
                    Inv_L = 1.0e-6 / leff;
                    Inv_W = 1.0e-6 / weff;
                    Inv_LW = 1.0e-12 / (leff * weff);
                end else begin
                    Inv_L = 1.0 / leff;
                    Inv_W = 1.0 / weff;
                    Inv_LW = 1.0 / (leff * weff);
                end

                cdsc = CDSC + LCDSC * Inv_L + WCDSC * Inv_W + PCDSC * Inv_LW;
                cdscb = CDSCB + LCDSCB * Inv_L + WCDSCB * Inv_W + PCDSCB * Inv_LW;
                cdscd = CDSCD + LCDSCD * Inv_L + WCDSCD * Inv_W + PCDSCD * Inv_LW;
                cit = CIT + LCIT * Inv_L + WCIT * Inv_W + PCIT * Inv_LW;
                nfactor = NFACTOR + LNFACTOR * Inv_L + WNFACTOR * Inv_W + PNFACTOR * Inv_LW;
                tnfactor = TNFACTOR + LTNFACTOR * Inv_L + WTNFACTOR * Inv_W + PTNFACTOR * Inv_LW;
                xj = XJ + LXJ * Inv_L + WXJ * Inv_W + PXJ * Inv_LW;
                vsat = VSAT + LVSAT * Inv_L + WVSAT * Inv_W + PVSAT * Inv_LW;
                at = AT + LAT * Inv_L + WAT * Inv_W + PAT * Inv_LW;
                a0 = A0 + LA0 * Inv_L + WA0 * Inv_W + PA0 * Inv_LW;
                ags = AGS + LAGS * Inv_L + WAGS * Inv_W + PAGS * Inv_LW;
                a1 = A1 + LA1 * Inv_L + WA1 * Inv_W + PA1 * Inv_LW;
                a2 = A2 + LA2 * Inv_L + WA2 * Inv_W + PA2 * Inv_LW;
                keta = KETA + LKETA * Inv_L + WKETA * Inv_W + PKETA * Inv_LW;
                nsub = NSUB + LNSUB * Inv_L + WNSUB * Inv_W + PNSUB * Inv_LW;
                ndep = NDEP + LNDEP * Inv_L + WNDEP * Inv_W + PNDEP * Inv_LW;
                nsd = NSD + LNSD * Inv_L + WNSD * Inv_W + PNSD * Inv_LW;
                phin = PHIN + LPHIN * Inv_L + WPHIN * Inv_W + PPHIN * Inv_LW;
                ngate = NGATE + LNGATE * Inv_L + WNGATE * Inv_W + PNGATE * Inv_LW;
                gamma1 = GAMMA1 + LGAMMA1 * Inv_L + WGAMMA1 * Inv_W + PGAMMA1 * Inv_LW;
                gamma2 = GAMMA2 + LGAMMA2 * Inv_L + WGAMMA2 * Inv_W + PGAMMA2 * Inv_LW;
                vbx = VBX + LVBX * Inv_L + WVBX * Inv_W + PVBX * Inv_LW;
                vbm = VBM + LVBM * Inv_L + WVBM * Inv_W + PVBM * Inv_LW;
                xt = XT + LXT * Inv_L + WXT * Inv_W + PXT * Inv_LW;
                vfb = VFB + LVFB * Inv_L + WVFB * Inv_W + PVFB * Inv_LW;
                k1 = K1 + LK1 * Inv_L + WK1 * Inv_W + PK1 * Inv_LW;
                kt1 = KT1 + LKT1 * Inv_L + WKT1 * Inv_W + PKT1 * Inv_LW;
                kt1l = KT1L + LKT1L * Inv_L + WKT1L * Inv_W + PKT1L * Inv_LW;
                k2 = K2 + LK2 * Inv_L + WK2 * Inv_W + PK2 * Inv_LW;
                kt2 = KT2 + LKT2 * Inv_L + WKT2 * Inv_W + PKT2 * Inv_LW;
                k3 = K3 + LK3 * Inv_L + WK3 * Inv_W + PK3 * Inv_LW;
                k3b = K3B + LK3B * Inv_L + WK3B * Inv_W + PK3B * Inv_LW;
                w0 = W0 + LW0 * Inv_L + WW0 * Inv_W + PW0 * Inv_LW;
                lpe0 = LPE0 + LLPE0 * Inv_L + WLPE0 * Inv_W + PLPE0 * Inv_LW;
                lpeb = LPEB + LLPEB * Inv_L + WLPEB * Inv_W + PLPEB * Inv_LW;
                dvtp0 = DVTP0 + LDVTP0 * Inv_L + WDVTP0 * Inv_W + PDVTP0 * Inv_LW;
                dvtp1 = DVTP1 + LDVTP1 * Inv_L + WDVTP1 * Inv_W + PDVTP1 * Inv_LW;
                dvtp2 = DVTP2 + LDVTP2 * Inv_L + WDVTP2 * Inv_W + PDVTP2 * Inv_LW;
                dvtp3 = DVTP3 + LDVTP3 * Inv_L + WDVTP3 * Inv_W + PDVTP3 * Inv_LW;
                dvtp4 = DVTP4 + LDVTP4 * Inv_L + WDVTP4 * Inv_W + PDVTP4 * Inv_LW;
                dvtp5 = DVTP5 + LDVTP5 * Inv_L + WDVTP5 * Inv_W + PDVTP5 * Inv_LW;
                dvt0 = DVT0 + LDVT0 * Inv_L + WDVT0 * Inv_W + PDVT0 * Inv_LW;
                dvt1 = DVT1 + LDVT1 * Inv_L + WDVT1 * Inv_W + PDVT1 * Inv_LW;
                dvt2 = DVT2 + LDVT2 * Inv_L + WDVT2 * Inv_W + PDVT2 * Inv_LW;
                dvt0w = DVT0W + LDVT0W * Inv_L + WDVT0W * Inv_W + PDVT0W * Inv_LW;
                dvt1w = DVT1W + LDVT1W * Inv_L + WDVT1W * Inv_W + PDVT1W * Inv_LW;
                dvt2w = DVT2W + LDVT2W * Inv_L + WDVT2W * Inv_W + PDVT2W * Inv_LW;
                drout = DROUT + LDROUT * Inv_L + WDROUT * Inv_W + PDROUT * Inv_LW;
                dsub = DSUB + LDSUB * Inv_L + WDSUB * Inv_W + PDSUB * Inv_LW;
                vth0 = VTH0 + LVTH0 * Inv_L + WVTH0 * Inv_W + PVTH0 * Inv_LW;
                ua = UA + LUA * Inv_L + WUA * Inv_W + PUA * Inv_LW;
                ua1 = UA1 + LUA1 * Inv_L + WUA1 * Inv_W + PUA1 * Inv_LW;
                ub = UB + LUB * Inv_L + WUB * Inv_W + PUB * Inv_LW;
                ub1 = UB1 + LUB1 * Inv_L + WUB1 * Inv_W + PUB1 * Inv_LW;
                uc = UC + LUC * Inv_L + WUC * Inv_W + PUC * Inv_LW;
                uc1 = UC1 + LUC1 * Inv_L + WUC1 * Inv_W + PUC1 * Inv_LW;
                ud = UD + LUD * Inv_L + WUD * Inv_W + PUD * Inv_LW;
                ud1 = UD1 + LUD1 * Inv_L + WUD1 * Inv_W + PUD1 * Inv_LW;
                up = UP + LUP * Inv_L + WUP * Inv_W + PUP * Inv_LW;
                lp = LP + LLP * Inv_L + WLP * Inv_W + PLP * Inv_LW;
                eu = EU + LEU * Inv_L + WEU * Inv_W + PEU * Inv_LW; //this doesn't work for some reason
                u0 = U0 + LU0 * Inv_L + WU0 * Inv_W + PU0 * Inv_LW;
                ute = UTE + LUTE * Inv_L + WUTE * Inv_W + PUTE * Inv_LW;
                ucs = UCS + LUCS * Inv_L + WUCS * Inv_W + PUCS * Inv_LW;
                ucste = UCSTE + LUCSTE * Inv_L + WUCSTE * Inv_W + PUCSTE * Inv_LW;
                voff = VOFF + LVOFF * Inv_L + WVOFF * Inv_W + PVOFF * Inv_LW;
                tvoff = TVOFF + LTVOFF * Inv_L + WTVOFF * Inv_W + PTVOFF * Inv_LW;
                minv = MINV + LMINV * Inv_L + WMINV * Inv_W + PMINV * Inv_LW;
                minvcv = MINVCV + LMINVCV * Inv_L + WMINVCV * Inv_W + PMINVCV * Inv_LW;
                fprout = FPROUT + LFPROUT * Inv_L + WFPROUT * Inv_W + PFPROUT * Inv_LW;
                pdits = PDITS + LPDITS * Inv_L + WPDITS * Inv_W + PPDITS * Inv_LW;
                pditsd = PDITSD + LPDITSD * Inv_L + WPDITSD * Inv_W + PPDITSD * Inv_LW;
                delta = DELTA + LDELTA * Inv_L + WDELTA * Inv_W + PDELTA * Inv_LW;
                rdsw = RDSW + LRDSW * Inv_L + WRDSW * Inv_W + PRDSW * Inv_LW;
                rdw = RDW + LRDW * Inv_L + WRDW * Inv_W + PRDW * Inv_LW;
                rsw = RSW + LRSW * Inv_L + WRSW * Inv_W + PRSW * Inv_LW;
                prwg = PRWG + LPRWG * Inv_L + WPRWG * Inv_W + PPRWG * Inv_LW;
                prwb = PRWB + LPRWB * Inv_L + WPRWB * Inv_W + PPRWB * Inv_LW;
                prt = PRT + LPRT * Inv_L + WPRT * Inv_W + PPRT * Inv_LW;
                eta0 = ETA0 + LETA0 * Inv_L + WETA0 * Inv_W + PETA0 * Inv_LW;
                teta0 = TETA0 + LTETA0 * Inv_L + WTETA0 * Inv_W + PTETA0 * Inv_LW; // 4.
                tvoffcv = TVOFFCV + LTVOFFCV * Inv_L + WTVOFFCV * Inv_W + PTVOFFCV * Inv_LW; // 4.8.
                etab = ETAB + LETAB * Inv_L + WETAB * Inv_W + PETAB * Inv_LW;
                pclm = PCLM + LPCLM * Inv_L + WPCLM * Inv_W + PPCLM * Inv_LW;
                pdibl1 = PDIBLC1 + LPDIBLC1 * Inv_L + WPDIBLC1 * Inv_W + PPDIBLC1 * Inv_LW; // these names don't match in the C either. I prommise it's not my fault.
                pdibl2 = PDIBLC2 + LPDIBLC2 * Inv_L + WPDIBLC2 * Inv_W + PPDIBLC2 * Inv_LW;
                pdiblb = PDIBLCB + LPDIBLCB * Inv_L + WPDIBLCB * Inv_W + PPDIBLCB * Inv_LW;
                pscbe1 = PSCBE1 + LPSCBE1 * Inv_L + WPSCBE1 * Inv_W + PPSCBE1 * Inv_LW;
                pscbe2 = PSCBE2 + LPSCBE2 * Inv_L + WPSCBE2 * Inv_W + PPSCBE2 * Inv_LW;
                pvag = PVAG + LPVAG * Inv_L + WPVAG * Inv_W + PPVAG * Inv_LW;
                wr = WR + LWR * Inv_L + WWR * Inv_W + PWR * Inv_LW;
                dwg = DWG + LDWG * Inv_L + WDWG * Inv_W + PDWG * Inv_LW;
                dwb = DWB + LDWB * Inv_L + WDWB * Inv_W + PDWB * Inv_LW;
                b0 = B0 + LB0 * Inv_L + WB0 * Inv_W + PB0 * Inv_LW;
                b1 = B1 + LB1 * Inv_L + WB1 * Inv_W + PB1 * Inv_LW;
                alpha0 = ALPHA0 + LALPHA0 * Inv_L + WALPHA0 * Inv_W + PALPHA0 * Inv_LW;
                alpha1 = ALPHA1 + LALPHA1 * Inv_L + WALPHA1 * Inv_W + PALPHA1 * Inv_LW;
                beta0 = BETA0 + LBETA0 * Inv_L + WBETA0 * Inv_W + PBETA0 * Inv_LW;
                agidl = AGIDL + LAGIDL * Inv_L + WAGIDL * Inv_W + PAGIDL * Inv_LW;
                bgidl = BGIDL + LBGIDL * Inv_L + WBGIDL * Inv_W + PBGIDL * Inv_LW;
                cgidl = CGIDL + LCGIDL * Inv_L + WCGIDL * Inv_W + PCGIDL * Inv_LW;
                egidl = EGIDL + LEGIDL * Inv_L + WEGIDL * Inv_W + PEGIDL * Inv_LW;
                rgidl = RGIDL + LRGIDL * Inv_L + WRGIDL * Inv_W + PRGIDL * Inv_LW;
                kgidl = KGIDL + LKGIDL * Inv_L + WKGIDL * Inv_W + PKGIDL * Inv_LW;
                fgidl = FGIDL + LFGIDL * Inv_L + WFGIDL * Inv_W + PFGIDL * Inv_LW;
                agisl = AGISL + LAGISL * Inv_L + WAGISL * Inv_W + PAGISL * Inv_LW;
                bgisl = BGISL + LBGISL * Inv_L + WBGISL * Inv_W + PBGISL * Inv_LW;
                cgisl = CGISL + LCGISL * Inv_L + WCGISL * Inv_W + PCGISL * Inv_LW;
                egisl = EGISL + LEGISL * Inv_L + WEGISL * Inv_W + PEGISL * Inv_LW;
                rgisl = RGISL + LRGISL * Inv_L + WRGISL * Inv_W + PRGISL * Inv_LW;
                kgisl = KGISL + LKGISL * Inv_L + WKGISL * Inv_W + PKGISL * Inv_LW;
                fgisl = FGISL + LFGISL * Inv_L + WFGISL * Inv_W + PFGISL * Inv_LW;
                aigc = AIGC + LAIGC * Inv_L + WAIGC * Inv_W + PAIGC * Inv_LW;
                bigc = BIGC + LBIGC * Inv_L + WBIGC * Inv_W + PBIGC * Inv_LW;
                cigc = CIGC + LCIGC * Inv_L + WCIGC * Inv_W + PCIGC * Inv_LW;
                aigsd = AIGSD + LAIGSD * Inv_L + WAIGSD * Inv_W + PAIGSD * Inv_LW;
                bigsd = BIGSD + LBIGSD * Inv_L + WBIGSD * Inv_W + PBIGSD * Inv_LW;
                cigsd = CIGSD + LCIGSD * Inv_L + WCIGSD * Inv_W + PCIGSD * Inv_LW;
                aigs = aigs + LAIGS * Inv_L + WAIGS * Inv_W + PAIGS * Inv_LW;
                bigs = bigs + LBIGS * Inv_L + WBIGS * Inv_W + PBIGS * Inv_LW;
                cigs = cigs + LCIGS * Inv_L + WCIGS * Inv_W + PCIGS * Inv_LW;
                aigd = aigd + LAIGD * Inv_L + WAIGD * Inv_W + PAIGD * Inv_LW;
                bigd = bigd + LBIGD * Inv_L + WBIGD * Inv_W + PBIGD * Inv_LW;
                cigd = cigd + LCIGD * Inv_L + WCIGD * Inv_W + PCIGD * Inv_LW;
                aigbacc = AIGBACC + LAIGBACC * Inv_L + WAIGBACC * Inv_W + PAIGBACC * Inv_LW;
                bigbacc = BIGBACC + LBIGBACC * Inv_L + WBIGBACC * Inv_W + PBIGBACC * Inv_LW;
                cigbacc = CIGBACC + LCIGBACC * Inv_L + WCIGBACC * Inv_W + PCIGBACC * Inv_LW;
                aigbinv = AIGBINV + LAIGBINV * Inv_L + WAIGBINV * Inv_W + PAIGBINV * Inv_LW;
                bigbinv = BIGBINV + LBIGBINV * Inv_L + WBIGBINV * Inv_W + PBIGBINV * Inv_LW;
                cigbinv = CIGBINV + LCIGBINV * Inv_L + WCIGBINV * Inv_W + PCIGBINV * Inv_LW;
                nigc = NIGC + LNIGC * Inv_L + WNIGC * Inv_W + PNIGC * Inv_LW;
                nigbacc = NIGBACC + LNIGBACC * Inv_L + WNIGBACC * Inv_W + PNIGBACC * Inv_LW;
                nigbinv = NIGBINV + LNIGBINV * Inv_L + WNIGBINV * Inv_W + PNIGBINV * Inv_LW;
                ntox = NTOX + LNTOX * Inv_L + WNTOX * Inv_W + PNTOX * Inv_LW;
                eigbinv = EIGBINV + LEIGBINV * Inv_L + WEIGBINV * Inv_W + PEIGBINV * Inv_LW;
                pigcd = PIGCD + LPIGCD * Inv_L + WPIGCD * Inv_W + PPIGCD * Inv_LW;
                poxedge = POXEDGE + LPOXEDGE * Inv_L + WPOXEDGE * Inv_W + PPOXEDGE * Inv_LW;
                xrcrg1 = XRCRG1 + LXRCRG1 * Inv_L + WXRCRG1 * Inv_W + PXRCRG1 * Inv_LW;
                xrcrg2 = XRCRG2 + LXRCRG2 * Inv_L + WXRCRG2 * Inv_W + PXRCRG2 * Inv_LW;
                lambda = LAMBDA + LLAMBDA * Inv_L + WLAMBDA * Inv_W + PLAMBDA * Inv_LW;
                vtl = VTL + LVTL * Inv_L + WVTL * Inv_W + PVTL * Inv_LW;
                xn = XN + LXN * Inv_L + WXN * Inv_W + PXN * Inv_LW;
                vfbsdoff = VFBSDOFF + LVFBSDOFF * Inv_L + WVFBSDOFF * Inv_W + PVFBSDOFF * Inv_LW;
                tvfbsdoff = TVFBSDOFF + LTVFBSDOFF * Inv_L + WTVFBSDOFF * Inv_W + PTVFBSDOFF * Inv_LW;
                cgsl = CGSL + LCGSL * Inv_L + WCGSL * Inv_W + PCGSL * Inv_LW;
                cgdl = CGDL + LCGDL * Inv_L + WCGDL * Inv_W + PCGDL * Inv_LW;
                ckappas = CKAPPAS + LCKAPPAS * Inv_L + WCKAPPAS * Inv_W + PCKAPPAS * Inv_LW;
                ckappad = CKAPPAD + LCKAPPAD * Inv_L + WCKAPPAD * Inv_W + PCKAPPAD * Inv_LW;
                cf = cf + LCF * Inv_L + WCF * Inv_W + PCF * Inv_LW;
                clc = CLC + LCLC * Inv_L + WCLC * Inv_W + PCLC * Inv_LW;
                cle = CLE + LCLE * Inv_L + WCLE * Inv_W + PCLE * Inv_LW;
                vfbcv = VFBCV + LVFBCV * Inv_L + WVFBCV * Inv_W + PVFBCV * Inv_LW;
                acde = ACDE + LACDE * Inv_L + WACDE * Inv_W + PACDE * Inv_LW;
                moin = MOIN + LMOIN * Inv_L + WMOIN * Inv_W + PMOIN * Inv_LW;
                noff = NOFF + LNOFF * Inv_L + WNOFF * Inv_W + PNOFF * Inv_LW;
                voffcv = VOFFCV + LVOFFCV * Inv_L + WVOFFCV * Inv_W + PVOFFCV * Inv_LW;
                kvth0we = KVTH0WE + LKVTH0WE * Inv_L + WKVTH0WE * Inv_W + PKVTH0WE * Inv_LW;
                k2we = K2WE + LK2WE * Inv_L + WK2WE * Inv_W + PK2WE * Inv_LW;
                ku0we = KU0WE + LKU0WE * Inv_L + WKU0WE * Inv_W + PKU0WE * Inv_LW;

                abulkCVfactor = 1.0 + pow(clc / leffCV, cle);
                T0 = TRatio - 1.0;

                PowWeffWr = pow(weffCJ * 1.0e6, wr) * NF;
                ucs = ucs * pow(TRatio, ucste);

                T1 = 0.0;
                T2 = 0.0;
                T3 = 0.0;
                T4 = 0.0;
                if (TEMPMOD == 0) begin
                    ua = ua + ua1 * T0;
                    ub = ub + ub1 * T0;
                    uc = uc + uc1 * T0;
                    ud = ud + ud1 * T0;
                    vsattemp = vsat - at * T0;
                    T10 = prt * T0;

                    if (RDSMOD != 0) begin
                        // External Rd(V)
                        T1 = rdw + T10;
                        T2 = RDWMIN + T10;
                        // External Rs(V)
                        T3 = rsw + T10;
                        T4 = RSWMIN + T10;
                    end

                    // Internal Rds(V) in IV
                    rds0 = (rdsw + T10) * NF / PowWeffWr;
                    rdswmin = (RDSWMIN + T10) * NF / PowWeffWr;
                end else begin
                    if (TEMPMOD == 3) begin
                        ua = ua * pow(TRatio, ua1);
                        ub = ub * pow(TRatio, ub1);
                        uc = uc * pow(TRatio, uc1);
                        ud = ud * pow(TRatio, ud1);
                    end else begin
                        // TEMPMOD 1 or 2
                        ua = ua * (1.0 + ua1 * delTemp);
                        ub = ub * (1.0 + ub1 * delTemp);
                        uc = uc * (1.0 + uc1 * delTemp);
                        ud = ud * (1.0 + ud1 * delTemp);
                    end
                    vsattemp = vsat * (1.0 - at * delTemp);
                    T10 = 1.0 + prt * delTemp;
                    if (RDSMOD != 0) begin
                        // External Rd(V)
                        T1 = rdw * T10;
                        T2 = RDWMIN * T10;
                        // External Rs(V)
                        T3 = rsw * T10;
                        T4 = RSWMIN * T10;
                    end

                    // Internal Rds(V) in IV
                    rds0 = rdsw * T10 * NF / PowWeffWr;
                    rdswmin = RDSWMIN * T10 * NF / PowWeffWr;
                end

                `define rtempcheck(T, name) if (T < 0.0) begin \
                    T = 0.0; \
                    $warning("Warning: ", name, " at current temperature is negative; set to 0."); \
                end

                `rtempcheck(T1, "Rdw")
                `rtempcheck(T2, "Rdwmin")
                `rtempcheck(T3, "Rsw")
                `rtempcheck(T4, "Rswmin")

                rd0 = T1 / PowWeffWr;
                rdwmin = T2 / PowWeffWr;
                rs0 = T3 / PowWeffWr;
                rswmin = T4 / PowWeffWr;

                if (u0 > 1.0)
                    u0 = u0 / 1.0e4;

                // mobility channel length dependence
                T5 = 1.0 - up * exp( - leff / lp );
                u0temp = u0 * T5 * pow(TRatio, ute);

                `define posclamp(val, name) if (val < 0.0) begin \
                    val = 0.0; \
                    $warning("Warning: ", name, " has been negative; reset to 0.0."); \
                end
                `posclamp(eu, "eu")
                `posclamp(ucs, "ucs")

                vfbsdoff = vfbsdoff * (1.0 + tvfbsdoff * delTemp);
                voff = voff * (1.0 + tvoff * delTemp);
                nfactor = nfactor + tnfactor * delTemp / tnom; // v4.7 temp dep of leakage currents
                voffcv = voffcv * (1.0 + tvoffcv * delTemp);  // v4.7 temp dep of leakage currents
                eta0 = eta0 + teta0 * delTemp / tnom;

                // Source End Velocity Limit
                if ($param_given(VTL) && VTL > 0.0) begin
                    if (LC < 0.0) begin
                        $warning("Warning: back scattering coeff LC = ", LC, " is too small. Reset to 0.0.");
                        T0 = leff / (xn * leff);
                    end else begin
                        T0 = leff / (xn * leff + LC);
                    end
                    tfactor = (1.0 - T0) / (1.0 + T0);
                end

                cgdo = (cgdo + cf) * weffCV;
                cgso = (cgso + cf) * weffCV;
                cgbo = cgbo * leffCV * NF;

                if (!$param_given(NDEP) && $param_given(GAMMA1)) begin
                    T0 = gamma1 * coxe;
                    ndep = 3.01248e22 * T0 * T0;
                end

                phi = Vtm0 * ln(ndep / ni) + phin + 0.4;
                sqrtPhi = Csqrt(phi);
                phis3 = sqrtPhi * phi;

                Xdep0 = sqrt(2.0 * epssub / (`Charge_q * ndep * 1.0e6)) * sqrtPhi;
                sqrtXdep0 = sqrt(Xdep0);

                // O&G break: continue from here
                if (MTRLMOD == 0)
                    litl = sqrt(3.0 * 3.9 / epsrox * xj * toxe);
                else
                    litl = sqrt(EPSRSUB / epsrox * xj * toxe);

                vbi = Vtm0 * ln(nsd * ndep / (ni * ni));

                if (MTRLMOD == 0) begin
                    if (ngate > 0.0)
                        vfbsd = Vtm0 * ln(ngate / nsd);
                    else
                        vfbsd = 0.0;
                end else begin
                    T0 = Vtm0 * ln(nsd/ni);
                    T1 = 0.5 * Eg0;
                    if (T0 > T1)
                        T0 = T1;
                    T2 = EASUB + T1 - TYPE * T0;
                    vfbsd = PHIG - T2;
                end
                cdep0 = sqrt(`Charge_q * epssub * ndep * 1.0e6 / 2.0 / phi);
                ToxRatio = exp(ntox * ln(TOXREF / toxe)) / toxe / toxe;
                ToxRatioEdge = exp(ntox * ln(TOXREF / (toxe * poxedge))) / toxe / toxe / poxedge / poxedge;
                Aechvb = TYPE == `ntype ? 4.97232e-7 : 3.42537e-7;
                Bechvb = TYPE == `ntype ? 7.45669e11 : 1.16645e12;

                if (VERSION > 4.80) begin
                    if (dlcig < 0.0) begin
                        dlcig = 0.0;
                        $warning("Warning: DLCIG has been negative; reset to 0.0.");
                    end
                    if (dlcigd < 0.0) begin
                        dlcigd = 0.0;
                        $warning("Warning: DLCIGD has been negative; reset to 0.0.");
                    end
                end
                AechvbEdgeS = Aechvb * weff * dlcig * ToxRatioEdge;
                AechvbEdgeD = Aechvb * weff * dlcigd * ToxRatioEdge;

                BechvbEdge = -Bechvb * toxe * poxedge;
                Aechvb = Aechvb * weff * leff * ToxRatio;
                Bechvb = Bechvb * -toxe;

                mstar = 0.5 + atan(minv) / `M_PI;
                mstarcv = 0.5 + atan(minvcv) / `M_PI;
                voffcbn = voff + VOFFL / leff;
                voffcbncv = voffcv + VOFFCVL / leff;

                ldeb = sqrt(epssub * Vtm0 / (`Charge_q * ndep * 1.0e6)) / 3.0;
                acde = acde * pow(ndep / 2.0e16, -0.25);

                if ($param_given(K1) || $param_given(K2)) begin
                    if (!$param_given(K1)) begin
                        $warning("Warning: k1 should be specified with k2");
                        k1 = 0.53;
                    end
                    if (!$param_given(K2)) begin
                        $warning("Warning: k2 should be specified with k1");
                        k2 = -0.0186;
                    end
                    if ($param_given(NSUB))
                        $warning("Warning: nsub is ignored because k1 or k2 is given.");
                    if ($param_given(XT))
                        $warning("Warning: xt is ignored because k1 or k2 is given.");
                    if ($param_given(VBX))
                        $warning("Warning: vbx is ignored because k1 or k2 is given.");
                    if ($param_given(GAMMA1))
                        $warning("Warning: gamma1 is ignored because k1 or k2 is given.");
                    if ($param_given(GAMMA2))
                        $warning("Warning: gamma2 is ignored because k1 or k2 is given.");
                end else begin
                    if (!$param_given(VBX))
                        vbx = phi - 7.7348e-4 * ndep * xt * xt;
                    if (vbx > 0.0)
                        vbx = -vbx;
                    if (vbm > 0.0)
                        vbm = -vbm;
                    if (!$param_given(GAMMA1))
                        gamma1 = 5.753e-12 * sqrt(ndep) / coxe;
                    if (!$param_given(GAMMA2))
                        gamma2 = 5.753e-12 * sqrt(nsub) / coxe;
                    T0 = gamma1 - gamma2;
                    T1 = sqrt(phi - vbx) - sqrtPhi;
                    T2 = sqrt(phi * (phi - vbm)) - phi;
                    k2 = T0 * T1 / (2.0 * T2 + vbm);
                    k1 = gamma2 - 2.0 * k2 * sqrt(phi - vbm);
                end

                if (!$param_given(VFB)) begin
                    if ($param_given(VTH0))
                        vfb = TYPE * vth0 - phi - k1 * sqrtPhi;
                    else begin
                        if (MTRLMOD != 0 && $param_given(PHIG) && $param_given(NSUB)) begin
                            T0 = Vtm0 * ln(nsub / ni);
                            T1 = 0.5 * Eg0;
                            if (T0 > T1)
                                T0 = T1;
                            T2 = EASUB + T1 + TYPE * T0;
                            vfb = PHIG - T2;
                        end else begin
                            vfb = -1.0;
                        end
                    end
                end

                if (!$param_given(VTH0))
                    vth0 = TYPE * (vfb + phi + k1 * sqrtPhi);

                k1ox = k1 * toxe / toxm;
                tmp = sqrt(epssub / (epsrox * `EPS0) * toxe * Xdep0);
                T0 = dsub * leff / tmp;

                theta0vb0 = expoexpm1(T0);

                T0 = drout * leff / tmp;
                T5 = expoexpm1(T0);

                thetaRout = pdibl1 * T5 + pdibl2;
                tmp = sqrt(Xdep0);
                tmp1 = vbi - phi;
                tmp2 = factor1 * tmp;

                T0 = dvt1w * weff * leff / tmp2;
                T8 = expoexpm1(T0);
                T0 = dvt0w * T8;
                T8 = T0 * tmp1;

                T0 = dvt1 * leff / tmp2;
                T9 = expoexpm1(T0);
                T9 = dvt0 * T9 * tmp1;
                T4 = toxe * phi / (weff + w0);
                T0 = sqrt(1.0 + lpe0 / leff);
                if (TEMPMOD == 1 || TEMPMOD == 0)
                    T3 = (kt1 + kt1l / leff) * (TRatio - 1.0);
                if (TEMPMOD == 2 || TEMPMOD == 3)
                    T3 = - kt1 * (TRatio - 1.0);

                T5 = k1ox * (T0 - 1.0) * sqrtPhi + T3;
                vfbzbfactor = -T8 - T9 + k3 * T4 + T5 - phi - k1 * sqrtPhi;

                // stress effect
                wlod = WLOD;
                // wlod clamp in parameter definition
                T0 = pow(Lnew, LLODKU0);
                W_tmp = Wnew + wlod;
                T1 = pow(W_tmp, WLODKU0);
                tmp1 = LKU0 / T0 + WKU0 / T1 + PKU0 / (T0 * T1);
                // pParam->BSIM4k0 in C. Renamed using name from manual
                // to disambiguate with model parameter.
                kstress_u0 = 1.0 + tmp1;

                T0 = pow(Lnew, LLODVTH);
                T1 = pow(W_tmp, WLODVTH);
                tmp1 = LKVTH0 / T0 + WKVTH0 / T1 + PKVTH0 / (T0 * T1);
                kvth0 = 1.0 + tmp1;
                kvth0 = sqrt(kvth0 * kvth0 + `DELTA);

                T0 = (TRatio - 1.0);
                ku0temp = kstress_u0 * (1.0 + TKU0 * T0) + `DELTA;

                Inv_saref = 1.0 / (SAREF + 0.5 * Ldrn);
                Inv_sbref = 1.0 / (SBREF + 0.5 * Ldrn);
                inv_od_ref = Inv_saref + Inv_sbref;
                rho_ref = KU0 / ku0temp * inv_od_ref;

                if (MOBMOD == 3) begin
                    lt1 = factor1 * sqrtXdep0;
                    T0 = dvt1 * leff / lt1;
                    Theta0 = expoexpm1(T0);
                    tmp1 = epssub / Xdep0;
                    tmp2 = nfactor * tmp1;
                    tmp3 = (tmp2 + cdsc * Theta0 + cit) / coxe;
                    if (tmp3 > -0.5)
                        n0 = 1.0 + tmp3;
                    else begin
                        T0 = 1.0 / (3.0 + 8.0 * tmp3);
                        n0 = (1.0 + 3.0 * tmp3) * T0;
                    end

                    T0 = n0 * vtm;
                    T1 = voffcbn;
                    T2 = T1/T0;
                    T3 = expclamp(T2) * coxe / cdep0;
                    T4 = mstar + T3 * n0;
                    VgsteffVth = T0 * ln(2.0)/T4;
                end

                T0 = -dvtp3 * ln(leff);
                T1 = DEXP(T0);
                dvtp2factor = dvtp5 + dvtp2 * T1;
            end // SizeDepCalc

            // stress effect
            if ( SA > 0.0 && SB > 0.0 && NF > 1.0 || (NF == 1.0 && SD > 0.0) ) begin
                Inv_sa = 0;
                Inv_sb = 0;

                for(i = 0; i < NF; i = i + 1) begin
                    T0 = 1.0 / NF / (SA + 0.5*Ldrn + i * (SD + Ldrn));
                    T1 = 1.0 / NF / (SB + 0.5*Ldrn + i * (SD + Ldrn));
                    Inv_sa = Inv_sa + T0;
                    Inv_sb = Inv_sb + T1;
                end

                Inv_ODeff = Inv_sa + Inv_sb;
                rho = KU0 / ku0temp * Inv_ODeff;

                T0 = (1.0 + rho)/(1.0 + rho_ref);
                u0temp = u0temp * T0;

                T1 = (1.0 + kvsat * rho)/(1.0 + kvsat * rho_ref);
                vsattemp = vsattemp * T1;

                OD_offset = Inv_ODeff - inv_od_ref;
                dvth0_lod = KVTH0 / kvth0 * OD_offset;
                dk2_lod = STK2 / pow(kvth0, LODK2) * OD_offset;
                deta0_lod = STETA0 / pow(kvth0, LODETA0) * OD_offset;
                vth0 = vth0 + dvth0_lod;
                eta0 = eta0 + deta0_lod;
                k2 = k2 + dk2_lod;
            end else begin
                // Nothing to do here in our formulation since we reuse these variables
            end

            // Well proximity effect
            if (WPEMOD != 0) begin
                if (!$param_given(SCA) && !$param_given(SCB) && !$param_given(SCC)) begin
                    if ($param_given(SC) && SC > 0.0) begin
                        T1 = SC + Wdrn;
                        T2 = 1.0 / scref;
                        sca = scref * scref / (SC * T1);
                        scb = ( (0.1 * SC + 0.001 * scref)  * exp(-10.0 * SC * T2) -
                            (0.1 * T1 + 0.01 * scref) * exp(-10.0 * T1 * T2) ) / Wdrn;
                        scc = ( (0.05 * SC + 0.0025 * scref)  * exp(-20.0 * SC * T2) -
                            (0.05 * T1 + 0.0025 * scref) * exp(-20.0 * T1 * T2) ) / Wdrn;
                    end else begin
                        $warning("Warning: No WPE as none of SCA, SCB, SCC, SC is given and/or SC not positive.");
                    end
                end

                // Clamping handled in parameter definition

                sceff = sca + WEB * scb + WEC * scc;
                vth0 = vth0 + kvth0we * sceff;
                k2 = k2 + k2we * sceff;

                T3 = 1.0 + ku0we * sceff;
                if (T3 <= 0.0) begin
                    T3 = 0.0;
                    $warning("Warning: ku0we = ", ku0we, " is negatively too high. Negative mobility!");
                end

                u0temp = u0temp * T3;
            end

            // adding DELVTO
            vth0 = vth0 + DELVTO;
            vfb = vfb + TYPE * DELVTO;

            u0temp = u0temp * MULU0;

            // Instance variables calculation
            T3 = TYPE * vth0 - vfb - phi;
            T4 = T3 + T3;
            T5 = 2.5 * T3;
            vtfbphi1 = TYPE == `ntype ? T4 : T5;
            if (vtfbphi1 < 0.0)
                vtfbphi1 = 0.0;

            vtfbphi2 = 4.0 * T3;
            if (vtfbphi2 < 0.0)
                vtfbphi2 = 0.0;

            if (k2 < 0.0) begin
                T0 = 0.5 * k1 / k2;
                vbsc = clamp(0.9 * (phi - T0 * T0), -30.0, -3.0);
            end else
                vbsc = -30.0;

            if (vbsc > vbm)
                vbsc = vbm;

            k2ox = k2 * toxe / toxm;
            vfbzb = vfbzbfactor + TYPE * vth0;

            lnl = ln(leff * 1.0e6);
            lnw = ln(weff * 1.0e6);
            lnnf = ln(NF);

            bodymode = 5;
            if (RBODYMOD == 2) begin
                if ( (!$param_given(RBPS0)) || (!$param_given(RBPD0)) )
                    bodymode = 1;
                else if ( ( !$param_given(RBSBX0) && !$param_given(RBSBY0) ) ||
                          ( !$param_given(RBDBX0)) && !$param_given(RBDBY0) )
                    bodymode = 3;

                if (bodymode == 5) begin
                    rbsbx = RBSBX0 * exp(RBSDBXL * lnl + RBSDBXW * lnw + RBSDBXNF * lnnf);
                    rbsby = RBSBY0 * exp(RBSDBYL * lnl + RBSDBYW * lnw + RBSDBYNF * lnnf);
                    rbsb = rbsbx * rbsby / (rbsbx + rbsby);  // TODO: should this be upper case?

                    rbdbx = RBDBX0 * exp(RBSDBXL * lnl + RBSDBXW * lnw + RBSDBXNF * lnnf);
                    rbdby = RBDBY0 * exp(RBSDBYL * lnl + RBSDBYW * lnw + RBSDBYNF * lnnf);
                    rbdb = rbdbx * rbdby / (rbdbx + rbdby);
                end

                if ((bodymode == 3) || (bodymode == 5)) begin
                    rbps = RBPS0 * exp(RBPSL * lnl + RBPSW * lnw + RBPSNF * lnnf);
                    rbpd = RBPD0 * exp(RBPDL * lnl + RBPDW * lnw + RBPDNF * lnnf);
                end

                rbpbx = RBPBX0 * exp(RBPBXL * lnl + RBPBXW * lnw + RBPBXNF * lnnf);
                rbpby = RBPBY0 * exp(RBPBYL * lnl + RBPBYW * lnw + RBPBYNF * lnnf);
                rbpb = rbpbx * rbpby / (rbpbx + rbpby);
            end

            if (RBODYMOD == 1 || (RBODYMOD == 2 && bodymode == 5)) begin
                grbdb = bound_grb(GBMIN, rbdb);
                grbpb = bound_grb(GBMIN, rbpb);
                grbps = bound_grb(GBMIN, rbps);
                grbsb = bound_grb(GBMIN, rbsb);
                grbpd = bound_grb(GBMIN, rbpd);
            end

            if (RBODYMOD == 2 && bodymode == 3) begin
                grbdb = GBMIN;
                grbsb = GBMIN;
                grbpb = bound_grb(GBMIN, rbpb);
                grbps = bound_grb(GBMIN, rbps);
                grbpd = bound_grb(GBMIN, rbpd);
            end

            if (RBODYMOD == 2 && bodymode == 1) begin
                grbdb = GBMIN;
                grbsb = GBMIN;
                grbps = 1.0e3;
                grbpd = 1.0e3;
                grbpb = bound_grb(GBMIN, rbpb);
            end

            // Proceess geometry dependent parasitics
            grgeltd = RSHG * (XGW + weffCJ / 3.0 / NGCON) / (NGCON * NF * (Lnew - XGL));
            if (grgeltd > 0.0)
                grgeltd = 1.0 / grgeltd;
            else begin
                grgeltd = 1.0e3; // mho
                if (RGATEMOD !=0)
                    $warning("Warning: The gate conductance reset to 1.0e3 mho");
            end

            DMCGeff = DMCG - DMCGT;
            DMCIeff = DMCI;
            DMDGeff = DMDG - DMCGT;

            // New Diode Model in 4.7
            if ($param_given(PS)) begin
                if (ps == 0.0)
                    PSeff = 0.0;
                else begin
                    // PS < 0.0 case handled in parameter def
                    if (PERMOD == 0)
                        PSeff = ps;
                    else
                        PSeff = ps - weffCJ * NF;
                end
            end else
                dummy = PAeffGEO(NF, GEOMOD, MIN, weffCJ, DMCGeff, DMCIeff, DMDGeff, PSeff, dumPd, dumAs, dumAs);

            if (PSeff < 0.0) begin
                //  v4.7 final check
                PSeff = 0.0;
                $warning("Warning: PSeff is negative, it is set to zero");
            end

            if ($param_given(PD)) begin
                if (pd == 0.0)
                    PDeff = 0.0;
                else begin
                    // PD < 0.0 case handled in parameter def
                    if (PERMOD == 0)
                        PDeff = pd;
                    else
                        PDeff = pd - weffCJ * NF;
                end
            end else
                dummy = PAeffGEO(NF, GEOMOD, MIN, weffCJ, DMCGeff, DMCIeff, DMDGeff, dumPs, PDeff, dumAs, dumAs);

            if (PDeff < 0.0) begin
                PDeff = 0.0; // v4.7
                $warning("Warning: PDeff is negative, it is set to zero");
            end

            if ($param_given(AS))
                ASeff = as;
            else
                dummy = PAeffGEO(NF, GEOMOD, MIN, weffCJ, DMCGeff, DMCIeff, DMDGeff, dumPs, dumPd, ASeff, dumAs);
            if (ASeff < 0.0) begin
                ASeff = 0.0; // v4.7
                $warning("Warning: ASeff is negative, it is set to zero");
            end

            if ($param_given(AD))
                ADeff = ad;
            else
                dummy = PAeffGEO(NF, GEOMOD, MIN, weffCJ, DMCGeff, DMCIeff, DMDGeff, dumPs, dumPd, dumAs, ADeff);
            if (ADeff < 0.0) begin
                ADeff = 0.0; // v4.7
                $warning("Warning: ADeff is negative, it is set to zero");
            end

            // TODO: support RGEOMOD scalings ???

            // From b4set.c
            createSourceNode = 0;
            if ( RDSMOD != 0 ) // || ( TNOIDMOD ==1 && $param_given(noiseAnal))
                createSourceNode = 1;
            else if (RSH > 0.0) begin
                if ($param_given(NRS) && NRS > 0)
                    createSourceNode = 1;
                else if (!$param_given(NRS) && RGEOMOD != 0) begin
                    // Duplicate calculation moved below
                    createSourceNode = 1;
                end
            end

            // Processing S/D resistances and conductance below
            if (createSourceNode == 1) begin
                if ($param_given(NRS))
                    sourceConductance = RSH * NRS;
                else if (RGEOMOD > 0)
                    sourceConductance = RdseffGeo(NF, GEOMOD, RGEOMOD, MIN, weffCJ, RSH, DMCGeff, DMCIeff, DMDGeff, 1);
                else
                    sourceConductance = 0.0;

                if (sourceConductance > 0.0)
                    sourceConductance = 1.0 / sourceConductance;
                else begin
                    sourceConductance = 1.0e3; // mho
                    $warning ("Warning: Source conductance reset to 1.0e3 mho");
                end
            end else begin
                V(s, si) <+ 0.0;
                sourceConductance = 0.0;
            end
            createDrainNode = 0;
            if ( RDSMOD != 0 ) // || ( TNOIDMOD ==1 && $param_given(noiseAnal))
                createDrainNode = 1;
            else if (RSH > 0.0) begin
                if ($param_given(NRD) && NRD > 0)
                    createDrainNode = 1;
                else if (!$param_given(NRD) && RGEOMOD != 0) begin
                    createDrainNode = 1;
                end
            end

            if (createDrainNode == 1) begin
                if ($param_given(NRD))
                    drainConductance = RSH * NRD;
                else if (GEOMOD > 0)
                    drainConductance = RdseffGeo(NF, GEOMOD, RGEOMOD, MIN, weffCJ, RSH, DMCGeff, DMCIeff, DMDGeff, 0);
                else
                    drainConductance = 0.0;

                if (drainConductance > 0.0)
                    drainConductance = 1.0 / drainConductance;
                else if (GEOMOD > 0)
                    drainConductance = 0.0; // createDrainNode = 0
                else begin
                    // Incorporates the createDrainNode conditions from b4set.c
                    drainConductance = 1.0e3; // mho
                    $warning ("Warning: Drain conductance reset to 1.0e3 mho");
                end
            end else begin
                V(d, di) <+ 0.0;
                drainConductance = 0.0;
            end

            Nvtms = vtm * NJS; // SjctEmissionCoeff
            if (ASeff <= 0.0 && PSeff <= 0.0)
                SourceSatCurrent = 0.0;
            else
                SourceSatCurrent = ASeff * SjctTempSatCurDensity +
                    PSeff * SjctSidewallTempSatCurDensity +
                    weffCJ * NF * SjctGateSidewallTempSatCurDensity;

            XExpBVS = 0.0;
            if (SourceSatCurrent > 0.0)
                case (DIOMOD)
                    0: XExpBVS = XJBVS * expclamplow(-BVS / Nvtms);
                    1: begin
                        vjSmFwd = DioIjthVjmEval(Nvtms, IJTHSFWD, SourceSatCurrent,
                                  0.0);
                        IvjSmFwd = SourceSatCurrent * exp(vjSmFwd / Nvtms);
                    end
                    2: begin
                        XExpBVS = XJBVS * expclamplow(-BVS / Nvtms);
                        vjSmFwd = DioIjthVjmEval(Nvtms, IJTHSFWD, SourceSatCurrent,
                                  XExpBVS);
                        T0 = exp(vjSmFwd / Nvtms);
                        IvjSmFwd = SourceSatCurrent * (T0 - XExpBVS / T0 + XExpBVS - 1.0);
                        SslpFwd = SourceSatCurrent * (T0 + XExpBVS / T0) / Nvtms;

                        T2 = IJTHSREV / SourceSatCurrent;
                        if (T2 < 1.0) begin
                            T2 = 10.0;
                            $warning("Warning: ijthsrev too small and set to 10 times IsbSat.\n");
                        end
                        vjSmRev = -BVS - Nvtms * ln((T2 - 1.0) / XJBVS);
                        T1 = XJBVS * exp(-(BVS + vjSmRev) / Nvtms);
                        IvjSmRev = SourceSatCurrent * (1.0 + T1);
                        SslpRev = -SourceSatCurrent * T1 / Nvtms;
                    end
                    default: $warning("Specified DIOMOD = ", DIOMOD, " not matched");
                endcase

            Nvtmd = vtm * NJD;
            if (ADeff <= 0.0 && PDeff <= 0.0)
                DrainSatCurrent = 0.0;
            else
                DrainSatCurrent = ADeff * DjctTempSatCurDensity +
                    PDeff * DjctSidewallTempSatCurDensity +
                    weffCJ * NF * DjctGateSidewallTempSatCurDensity;

            XExpBVD = 0.0;
            if (DrainSatCurrent > 0.0)
                case (DIOMOD)
                    0: XExpBVD = XJBVD * expclamplow(-BVD / Nvtmd);
                    1: begin
                        vjDmFwd = DioIjthVjmEval(Nvtmd, IJTHDFWD, DrainSatCurrent,
                                  0.0);
                        IvjDmFwd = DrainSatCurrent * exp(vjDmFwd / Nvtmd);
                    end
                    2: begin
                        XExpBVD = XJBVD * expclamplow(-BVD / Nvtmd);
                        vjDmFwd = DioIjthVjmEval(Nvtmd, IJTHDFWD, DrainSatCurrent,
                                  XExpBVD);
                        T0 = exp(vjDmFwd / Nvtmd);
                        IvjDmFwd = DrainSatCurrent * (T0 - XExpBVD / T0 + XExpBVD - 1.0);
                        DslpFwd = DrainSatCurrent * (T0 + XExpBVD / T0) / Nvtmd;
                        T2 = IJTHDREV / DrainSatCurrent;
                        if (T2 < 1.0) begin
                            T2 = 10.0;
                            $warning("Warning: ijthdrev too small and set to 10 times IdbSat.\n");
                        end
                        vjDmRev = -BVD - Nvtmd * ln((T2 - 1.0) / XJBVD);
                        T1 = XJBVD * exp(-(BVD + vjDmRev) / Nvtmd);
                        IvjDmRev = DrainSatCurrent * (1.0 + T1);
                        DslpRev = -DrainSatCurrent * T1 / Nvtmd;
                    end
                    default: $strobe("Specified DIOMOD = ", DIOMOD, " not matched");
                endcase

            T0 = (TRatio - 1.0);
            njtsstemp = NJTS * (1.0 + TNJTS * T0);
            njtsswstemp = NJTSSW * (1.0 + TNJTSSW * T0);
            njtsswgstemp = NJTSSWG * (1.0 + TNJTSSWG * T0);
            njtsdtemp = NJTSD * (1.0 + TNJTSD * T0);
            njtsswdtemp = NJTSSWD * (1.0 + TNJTSSWD * T0);
            njtsswgdtemp = NJTSSWGD * (1.0 + TNJTSSWGD * T0);
            T7 = Eg0 / vtm * T0;
            T1 = DEXP(XTSS * T7);
            T2 = DEXP(XTSD * T7);
            T3 = DEXP(XTSSWS * T7);
            T4 = DEXP(XTSSWD * T7);
            T5 = DEXP(XTSSWGS * T7);
            T6 = DEXP(XTSSWGD * T7);

            if (JTWEFF < 0.0) begin
                $strobe("TAT width dependence effect is negative. Jtweff is clamped to zero.");
                T11 = 1.0;
            end else begin
                T11 = sqrt(JTWEFF / weffCJ) + 1.0;
            end
            T10 = weffCJ * NF;

            SjctTempRevSatCur = T1 * ASeff * JTSS;
            DjctTempRevSatCur = T2 * ADeff * JTSD;
            SswTempRevSatCur = T3 * PSeff * JTSSWS;
            DswTempRevSatCur = T4 * PDeff * JTSSWD;
            SswgTempRevSatCur = T5 * T10 * T11 * JTSSWGS;
            DswgTempRevSatCur = T6 * T10 * T11 * JTSSWGD;

            if (MTRLMOD != 0 && MTRLCOMPATMOD == 0) begin
                // Calculate TOXP from EOT
                // Calculate Vgs_eff @ Vgs = VDD with Poly Depletion Effect
                Vtm0eot = `KboQ * tempeot;
                Vtmeot = Vtm0eot;
                vbieot = Vtm0eot * ln(nsd * ndep / (ni * ni));
                phieot = Vtm0eot * ln(ndep / ni) + phin + 0.4;
                tmp2 = vfb + phieot;
                vddeot = TYPE * VDDEOT;
                T0 = EPSRGATE * `EPS0;
                if (ngate > 1.0e18 && ngate < 1.0e25 && vddeot > tmp2 && T0 != 0) begin
                    T1 = 1.0e6 * `P_Q * T0 * ngate / (coxe * coxe);
                    T8 = vddeot - tmp2;
                    T4 = sqrt(1.0 + 2.0 * T8 / T1);
                    T2 = 2.0 * T8 / (T4 + 1.0);
                    T3 = 0.5 * T2 * T2 / T1;
                    T7 = 1.12 - T3 - 0.05;
                    T6 = sqrt(T7 * T7 + 0.224);
                    T5 = 1.12 - 0.5 * (T7 + T6);
                    Vgs_eff = vddeot - T5;
                end else
                    Vgs_eff = vddeot;

                // Calculate Vth @ Vds=Vbs=0
                V0 = vbieot - phieot;
                lt1 = factor1 * sqrtXdep0;
                ltw = lt1;
                T0 = dvt1 * LEFFEOT / lt1;
                Theta0 = expoexpm1(T0);
                Delt_vth = dvt0 * Theta0 * V0;
                T0 = dvt1w * WEFFEOT * LEFFEOT / ltw;
                T5 = expoexpm1(T0);
                T2 = dvt0w * T5 * V0;
                TempRatioeot = tempeot / tnom - 1.0;
                T0 = sqrt(1.0 + lpe0 / LEFFEOT);
                T1 = k1ox * (T0 - 1.0) * sqrt(phieot) + (kt1 + kt1l / LEFFEOT) * TempRatioeot;
                Vth_NarrowW = toxe * phieot / (WEFFEOT + w0);
                Lpe_Vb = sqrt(1.0 + lpeb / LEFFEOT);
                Vth = TYPE * vth0 + (k1ox - k1) * sqrt(phieot) * Lpe_Vb -
                    Delt_vth - T2 + k3 * Vth_NarrowW + T1;

                // Calculate n
                tmp1 = epssub / Xdep0;
                tmp2 = nfactor * tmp1;
                tmp3 = (tmp2 + cdsc * Theta0 + cit) / coxe;
                if (tmp3 >= -0.5)
                    n = 1.0 + tmp3;
                else begin
                    T0 = 1.0 / (3.0 + 8.0 * tmp3);
                    n = (1.0 + 3.0 * tmp3) * T0;
                end

                // Vth correction for Pocket implant
                if (dvtp0 > 0.0) begin
                    T3 = LEFFEOT + dvtp0 * 2.0;
                    if (TEMPMOD < 2)
                        T4 = Vtmeot * ln(LEFFEOT / T3);
                    else
                        T4 = Vtm0eot * ln(LEFFEOT / T3);
                    Vth = Vth - n * T4;
                end
                Vgsteff = Vgs_eff - Vth;

                // Calculating Toxp
                T3 = TYPE * vth0 - vfb - phieot;
                T4 = T3 + T3;
                T5 = 2.5 * T3;

                vtfbphi2eot = 4.0 * T3;
                if (vtfbphi2eot < 0.0)
                    vtfbphi2eot = 0.0;

                niter = 0;
                toxpf = toxe;
                while ((niter == 0) || (niter <= 4 && abs(toxpf - toxpi) > 1e-12)) begin
                    toxpi = toxpf;
                    tmp2 = 2.0e8 * toxpf;
                    T0 = (Vgsteff + vtfbphi2eot) / tmp2;
                    T1 = 1.0 + exp(BDOS * 0.7 * ln(T0));
                    Tcen = ADOS * 1.9e-9 / T1;
                    toxpf = toxe - epsrox/EPSRSUB * Tcen;
                    niter = niter + 1;
                end
                toxp = toxpf;
                coxp = epsrox * `EPS0 / toxp;
            end else begin
                // toxp defined above
                // coxp defined above
            end
        end // B4BiasIndepCalc

        begin : CheckModel
            // Model parameter bounds are part of parameter definition.
            // Only calculated values and those depending on multiple model parameters
            // are checked here.

            if ((RGATEMOD == 2 || RGATEMOD == 3) && (TRNQSMOD == 1 || ACNQSMOD == 1))
                $warning("Warning: You've selected both Rg and charge deficit NQS; select one only.");

            if (toxp < 0.0)
                $error("Toxp = ", toxp, " is not positive");

            if (lpe0 < -leff)
                $error("Lpe0 = ", lpe0, " is less than -Leff");

            if (LINTNOI > leff / 2)
                $error("Lintnoi = ", lintnoi, " is too large - Leff for noise is negative");

            if (lpeb < -leff)
                $error("Fatal: Lpeb = ", lpeb, " is less than -Leff");

            if (ndep <= 0.0)
                $error("Ndep = ", ndep, " is not positive");

            if (phi <= 0.0)
                $error("Phi = ", phi, " is not positive. Please check Phin and Ndep.",
                       "\n Phin = ", phin, "  Ndep = ", ndep);

            if (nsub <= 0.0)
                $error("Nsub = ", nsub, " is not positive");

            if (ngate < 0.0)
                $error("Ngate = ", ngate, " is not positive");

            if (ngate > 1e25)
                $error("Ngate = ", ngate, " is too high");

            if (xj <= 0.0)
                $error("Xj = ", xj, " is not positive");

            if (dvt1 < 0.0)
                $error("Dvt1 = ", dvt1, " is negative");

            if (dvt1w < 0.0)
                $error("Dvt1w = ", dvt1w, " is negative");

            if (w0 == -weff)
                $error("(W0 + Weff) = 0 causing divided-by-zero.");

            if (dsub < 0.0)
                $error("Dsub = ", dsub, " is negative");

            if (b1 == -weff)
                $error("(B1 + Weff) = 0 causing divided-by-zero.");

            if (u0temp <= 0.0)
                $error("(u0 at current temperature) = ", u0temp, " is not positive");

            if (delta < 0.0)
                $error("Delta = ", delta, " is is less than zero");

            if (vsattemp <= 0.0)
                $strobe("Vsat at current temperature = ", vsattemp, " is not positive");

            if (pclm <= 0.0)
                $error("Pclm = ", pclm, " is not positive");

            if (drout < 0.0)
                $error("Drout = ", drout, " is negative");

            if (l + XL <= XGL)
                $error("Fatal: The parameter xgl must be smaller than Ldrawn+XL.");

            // Check saturation parameters
            if (fprout < 0.0)
                $error("fprout = ", fprout, " is negative");

            if (pdits < 0.0)
                $error("pdits = ", pdits, " is negative");

            if (PDITSL < 0.0)
                $error("pditsl = ", PDITSL, " is negative");

            // Check gate current parameters
            if (IGBMOD != 0) begin
                if (nigbinv <= 0.0)
                    $error("nigbinv = ", nigbinv, " is not positive");

                if (nigbacc <= 0.0)
                    $error("nigbacc = ", nigbacc, " is not positive");
            end

            if (IGCMOD != 0) begin
                if (nigc <= 0.0)
                    $error("nigc = ", nigc, " is not positive");

                if (poxedge <= 0.0)
                    $error("poxedge = ", poxedge, " is not positive");

                if (pigcd <= 0.0)
                    $error("pigcd = ", pigcd, " is not positive");
            end

            if (clc < 0.0)
                $error("clc = ", clc, " is negative");

            if (ckappas < 0.02) begin
                $warning("Warning: ckappas = ", ckappas, " is too small. Set to 0.02");
                ckappas = 0.02;
            end

            if (ckappad < 0.02) begin
                $warning("Warning: ckappad = ", ckappad, " is too small. Set to 0.02");
                ckappad = 0.02;
            end

            if (PARAMCHK == 1) begin
                // Check L and W parameters
                if (leff <= 1.0e-9)
                    $warning("Warning: Leff = ", leff, " <= 1.0e-9. Recommended Leff >= 1e-8");

                if (leffCV <= 1.0e-9)
                    $warning("Warning: Leff for CV = ", leffCV, " <= 1.0e-9. Recommended LeffCV >= 1e-8");

                if (weff <= 1.0e-9)
                    $warning("Warning: Weff = ", weff, " <= 1.0e-9. Recommended Leff >= 1e-8");

                if (weffCV <= 1.0e-9)
                    $warning("Warning: Weff for CV = ", weffCV, " <= 1.0e-9. Recommended WeffCV >= 1e-8");

                // Check threshold voltage parameters
                if (toxe < 1.0e-10)
                    $warning("Warning: Toxe = ", toxe, " is less than 1A. Recommended Toxe >= 5A");

                if (toxp < 1.0e-10)
                    $warning("Warning: Toxp = ", toxp, " is less than 1A. Recommended Toxp >= 5A");

                if (toxm < 1.0e-10)
                    $warning("Warning: Toxm = ", toxm, " is less than 1A. Recommended Toxm >= 5A");

                if (ndep <= 1.0e12)
                    $warning("Warning: Ndep = ", ndep, " may be too small.");

                if (ndep >= 1.0e21)
                    $warning("Warning: Ndep = ", ndep, " may be too large.");

                if (nsub <= 1.0e12)
                    $warning("Warning: Nsub = ", nsub, " may be too small.");

                if (nsub >= 1.0e21)
                    $warning("Warning: Nsub = ", nsub, " may be too large.");

                if (ngate > 0 && ngate <= 1.0e18)
                    $warning("Warning: Ngate = ", ngate, " is less than 1.E18cm^-3.");

                if (dvt0 < 0.0)
                    $strobe("Dvt0 = ", dvt0, " is negative");

                if (abs(1.0e-8 / (w0 + weff)) > 10)
                    $warning("Warning: (W0 + Weff) may be too small.");

                // Check subthreshold parameters
                if (nfactor < 0.0)
                    $strobe("Nfactor = ", nfactor, " is negative");

                if (cdsc < 0.0)
                    $strobe("cdsc = ", cdsc, " is negative");

                if (cdscd < 0.0)
                    $strobe("cdscd = ", cdscd, " is negative");

                // Check DIBL parameters
                if (eta0 < 0.0)
                    $strobe("Eta0 = ", eta0, " is negative");

                // Check Abulk parameters
                if (abs(1.0e-8 / (b1 + weff)) > 10)
                    $warning("Warning: (B1 + Weff) may be too small.");

                // Check Saturation parameters
                if (a2 < 0.01) begin
                    $warning("Warning: A2 = ", a2, " is too small. Set to 0.01.");
                    a2 = 0.01;
                end else if (a2 > 1.0) begin
                    $warning("Warning: A2 = ", a2, " is larger than 1. A2 is set to 1 and A1 is set to 0.");
                    a2 = 1.0;
                    a1 = 0.0;
                end

                if (prwg < 0.0) begin
                    $strobe("Prwg = ", prwg, " is negative. Set to zero.");
                    prwg = 0.0;
                end

                if (rdsw < 0.0) begin
                    $strobe("Rdsw = ", rdsw, " is negative. Set to zero");
                    rdsw = 0.0;
                    rds0 = 0.0;
                end

                if (rds0 < 0.0) begin
                    $strobe("Rds0 = ", rds0, " is negative. Set to zero");
                    rds0 = 0.0;
                end

                if (rdswmin < 0.0) begin
                    $strobe("(Rdswmin at current temperature) = ", rdswmin, " is negative. Set to zero");
                    rdswmin = 0.0;
                end

                if (pscbe2 <= 0.0)
                    $strobe("pscbe2 = ", pscbe2, " is not positive");

                if (vsattemp < 1.0e3)
                    $warning("Warning: (Vsat at current temperature) = ", vsattemp, " may be too small.");

                if ($param_given(LAMBDA) && lambda > 1.0e-9)
                    $warning("Warning: Lambda = ", lambda, " may be too large.");

                if ($param_given(VTL) && vtl > 0.0 && vtl < 5.0e4)
                    $warning("Warning: Thermal velocity vtl = ", vtl, " may be too small.");

                if (xn < 3.0) begin
                    $warning("Warning: back scattering coeff xn = ", xn, " is less than 3. Set to 3.");
                    xn = 3.0;
                end

                if (pdibl1 < 0.0)
                    $warning("Warning: pdibl1 = ", pdibl1, " is negative.");

                if (pdibl2 < 0.0)
                    $warning("Warning: pdibl2 = ", pdibl2, " is negative.");

                if (RGATEMOD == 1)
                    if (RSHG <= 0.0)
                        $warning("Warning: Rshg = ", RSHG, " should be positive for rgateMod = 1.");
                else if (RGATEMOD == 2 || RGATEMOD == 3) begin
                    if (RSHG <= 0.0)
                        $warning("Warning: Rshg = ", RSHG, " should be positive for rgateMod = ", RGATEMOD, ".");
                    else if (xrcrg1 <= 0.0)
                        $warning("Warning: xrcrg1 = ", xrcrg1, " should be positive for rgateMod = ", RGATEMOD, ".");
                end

                if (noff < 0.1)
                    $warning("Warning: noff = ", noff, " is too small.");

                if (voffcv < -0.5)
                    $warning("Warning: Voffcv = ", voffcv, " is too small.");

                if (moin < 5.0)
                    $warning("Warning: Moin = ", moin, " is too small.");

                if (moin > 25.0)
                    $warning("Warning: Moin = ", moin, " is too large.");

                if (CAPMOD == 2) begin
                    if (acde < 0.1)
                        $warning("Warning: Acde = ", acde, " is too small.");

                    if (acde > 1.6)
                        $warning("Warning: Acde = ", acde, " is too large.");
                end

                if (TNOIMOD == 1)
                    $warning("Warning: TNOIMOD=1 is not supported and may be removed from future version.");

                if (IDOVVDSC <= 0.0)
                    $warning("Warning: IDOVVDSC = ", IDOVVDSC, " is non-positive.");

                if (NJS < 0.7)
                    $warning("Warning: NJS = ", NJS, " is less than 0.7.");

                if (NJS < 0.7)
                    $warning("Warning: NJD = ", NJD, " is less than 0.7.");

                if (njtsstemp < 0.0)
                    $warning("Warning: Njts = ", njtsstemp, " is negative at temperature = ", $temperature);

                if (njtsswstemp < 0.0)
                    $warning("Warning: Njtssw = ", njtsswstemp, " is negative at temperature = ", $temperature);

                if (njtsswgstemp < 0.0)
                    $warning("Warning: Njtsswg = ", njtsswgstemp, " is negative at temperature = ", $temperature);

                if ($param_given(NJTSD) && njtsdtemp < 0.0)
                    $warning("Warning: Njtsd = ", njtsdtemp, " is negative at temperature = ", $temperature);

                if ($param_given(NJTSSWD) && njtsswdtemp < 0.0)
                    $warning("Warning: Njtsswd = ", njtsswdtemp, " is negative at temperature = ", $temperature);

                if ($param_given(NJTSSWGD) && njtsswgdtemp < 0.0)
                    $warning("Warning: Njtsswgd = ", njtsswgdtemp, " is negative at temperature = ", $temperature);

                if (WPEMOD == 1 && scref <= 0.0) begin
                    $warning("Warning: SCREF = ", SCREF, " is not positive. Set to 1e-6");
                    scref = 1e-6;
                end
            end
        end // CheckModel

        vds = TYPE * V(di, si);
        vgs = TYPE * V(gi, si);
        vbs = TYPE * V(bi, si);
        vges = TYPE * V(g, si);
        vgms = TYPE * V(gm, si);
        vdbs = TYPE * V(db, si);
        vsbs = TYPE * V(sb, si);
        vses = TYPE * V(s, si);
        vdes = TYPE * V(d, si);
        qdef = TYPE * V(q);

        // N.B: b4ld.c computes the time derivatives manually.
        // Here's a handy translation:
        //
        //--------------------------
        // b4ld.c | bsim4.va
        // ----------------
        //         cggb | ddx(qgate, V(gi))
        //         cgdb | ddx(qgate, V(di))
        //         cgsb | ddx()
        //         cbgb | ddx()
        //         cbdb | ddx()
        //         cbsb | ddx()
        // G{m,mb,ds}

        //      g | BSIM4gNodeExt
        //      s | BSIM4sNode
        //      b | BSIM4bNode
        //     di | BSIM4dNodePrime
        //     si | BSIM4sNodePrime
        //     gi | BSIM4gNodePrime
        //     bi | BSIM4bNodePrime
        //     gm | BSIM4gNodeMid
        //     db | BSIM4dbNode
        //     sb | BSIM4sbNode
        //      q | BSIM4qNode
        //--------------------------

        // TODO: Voltage limiting (https://github.com/JuliaComputing/SPICEFrontend.jl/issues/109)

        // Calculate DC currents
        vbd = vbs - vds;
        vgd = vgs - vds;
        vgb = vgs - vbs; // V(gi, bi)
        vged = vges - vds;
        vgmd = vgms - vds;
        vgmb = vgms - vbs;
        vdbd = vdbs - vds;

        vbs_jct = RBODYMOD == 0 ? vbs : vsbs;
        vbd_jct = RBODYMOD == 0 ? vbd : vdbd;

        // TODO: These should also compute gbd / gbs (which we have as observed)

        Nvtms = vtm * NJS;
        if (ASeff <= 0.0 && PSeff <= 0.0)
            SourceSatCurrent = 0.0;
        else
            SourceSatCurrent = ASeff * SjctTempSatCurDensity +
                PSeff * SjctSidewallTempSatCurDensity +
                weffCJ * NF * SjctGateSidewallTempSatCurDensity;

        if (SourceSatCurrent <= 0.0)
            cbs = `GMIN * vbs_jct;
        else case (DIOMOD)
            0: begin
                evbs = exp(vbs_jct / Nvtms);
                T1 = XJBVS * exp(-(BVS + vbs_jct) / Nvtms);
                cbs = SourceSatCurrent * (evbs + XExpBVS - T1 - 1.0) + `GMIN * vbs_jct;
            end
            1: begin
                T2 = vbs_jct / Nvtms;
                if (T2 < -`EXP_THRESHOLD)
                    cbs = SourceSatCurrent * (`MIN_EXP - 1.0) + `GMIN * vbs_jct;
                else if (vbs_jct <= vjSmFwd)
                    cbs = SourceSatCurrent * (exp(T2) - 1.0) + `GMIN * vbs_jct;
                else
                    cbs = IvjSmFwd - SourceSatCurrent + IvjSmFwd /
                            Nvtms * (vbs_jct - vjSmFwd) + `GMIN * vbs_jct;
            end
            2: begin
                if (vbs_jct < vjSmRev) begin
                    T0 = vbs_jct / Nvtms;
                    evbs = expclamplow(T0);
                    T1 = evbs - 1.0;
                    T2 = IvjSmRev + SslpRev * (vbs_jct - vjSmRev);
                    cbs = T1 * T2 + `GMIN * vbs_jct;
                end else if (vbs_jct <= vjSmFwd) begin
                    T0 = vbs_jct / Nvtms;
                    evbs = expclamplow(T0);
                    T1 = (BVS + vbs_jct) / Nvtms;
                    T2 = expclamplow(-T1);
                    cbs = SourceSatCurrent *
                        (evbs + XExpBVS - 1.0 - XJBVS * T2) +
                        `GMIN * vbs_jct;
                end else
                    cbs = IvjSmFwd + SslpFwd * (vbs_jct - vjSmFwd)
                        + `GMIN * vbs_jct;
            end
        endcase

        Nvtmd = vtm * NJD;
        if (ADeff <= 0.0 && PDeff <= 0.0)
            DrainSatCurrent = 0.0;
        else
            DrainSatCurrent = ADeff * DjctTempSatCurDensity +
                PDeff * DjctSidewallTempSatCurDensity +
                weffCJ * NF * DjctGateSidewallTempSatCurDensity;

        if (DrainSatCurrent <= 0.0)
            cbd = `GMIN * vbd_jct;
        else case (DIOMOD)
            0: begin
                evbd = exp(vbd_jct / Nvtmd);
                T1 = XJBVD * exp(-(BVD + vbd_jct) / Nvtmd);
                cbd = DrainSatCurrent * (evbd + XExpBVD - T1 - 1.0) + `GMIN * vbd_jct;
            end
            1: begin
                T2 = vbd_jct / Nvtmd;
                if (T2 < -`EXP_THRESHOLD)
                    cbd = DrainSatCurrent * (`MIN_EXP - 1.0) + `GMIN * vbd_jct;
                else if (vbd_jct <= vjDmFwd)
                    cbd = DrainSatCurrent * (exp(T2) - 1.0) + `GMIN * vbd_jct;
                else
                    cbd = IvjDmFwd - DrainSatCurrent + IvjDmFwd /
                            Nvtmd * (vbd_jct - vjDmFwd) + `GMIN * vbd_jct;
            end
            2: begin
                if (vbd_jct < vjDmRev) begin
                    T0 = vbd_jct / Nvtmd;
                    evbd = expclamplow(T0);
                    T1 = evbd - 1.0;
                    T2 = IvjDmRev + DslpRev * (vbd_jct - vjDmRev);
                    cbd = T1 * T2 + `GMIN * vbd_jct;
                end else if (vbd_jct <= vjDmFwd) begin
                    T0 = vbd_jct / Nvtmd;
                    evbd = expclamplow(T0);
                    T1 = (BVD + vbd_jct) / Nvtmd;
                    T2 = expclamplow(-T1);
                    cbd = DrainSatCurrent *
                        (evbd + XExpBVD - 1.0 - XJBVD * T2) +
                        `GMIN * vbd_jct;
                end else
                    cbd = IvjDmFwd + DslpFwd * (vbd_jct - vjDmFwd)
                        + `GMIN * vbd_jct;
            end
        endcase

        T1 = vtmexp(Vtm0, vbs_jct, njtsstemp, VTSS);
        T2 = vtmexp(Vtm0, vbd_jct, njtsdtemp, VTSD);
        T3 = vtmexp(Vtm0, vbs_jct, njtsswstemp, VTSSWS);
        T4 = vtmexp(Vtm0, vbd_jct, njtsswdtemp, VTSSWD);
        T5 = vtmexp(Vtm0, vbs_jct, njtsswgstemp, VTSSWGS);
        T6 = vtmexp(Vtm0, vbd_jct, njtsswgdtemp, VTSSWGD);

        cbs = cbs - (SjctTempRevSatCur * (T1 - 1.0) +
               SswTempRevSatCur * (T3 - 1.0) +
               SswgTempRevSatCur * (T5 - 1.0));

        cbd = cbd - (DjctTempRevSatCur * (T2 - 1.0) +
               DswTempRevSatCur * (T4 - 1.0) +
               DswgTempRevSatCur * (T6 - 1.0));
        // End of DC diode model

        if (vds >= 0.0) begin
            sigvds = 1.0;
            Vds = vds;
            Vgs = vgs;
            Vbs = vbs;
            Vdb = vds - vbs; // ??? Never actually used anywhere
        end else begin
            sigvds = -1.0;
            Vds = -vds;
            Vgs = vgd;
            Vbs = vbd;
            Vdb = -vbs;
        end

        // dunga
        // MTRLMOD update already done above

        T0 = Vbs - vbsc - 0.001;
        T1 = sqrt(T0 * T0 - 0.004 * vbsc);
        if (T0 >= 0.0)
            Vbseff = vbsc + 0.5 * (T0 + T1);
        else begin
            T2 = -0.002 / (T1 - T0);
            Vbseff = vbsc * (1.0 + T2);
        end

        // JX: Correction to forward body bias
        T9 = 0.95 * phi;
        T0 = T9 - Vbseff - 0.001;
        T1 = sqrt(T0 * T0 + 0.004 * T9);
        Vbseff = T9 - 0.5 * (T0 + T1);
        Phis = phi - Vbseff;
        sqrtPhis = sqrt(Phis);
        Xdep = Xdep0 * sqrtPhis / sqrtPhi;

        // this line isn't really needed, but in b4temp, leff and Leff are different so this makes debugging easier
        Leff = leff;
        // Vth Calculation
        T3 = sqrt(Xdep);
        V0 = vbi - phi;
        T0 = dvt2 * Vbseff;

        if (T0 >= -0.5) begin
            T1 = 1.0 + T0;
            T2 = dvt2;
        end else begin
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4;
            T2 = dvt2 * T4 * T4;
        end

        lt1 = factor1 * T3 * T1;

        T0 = dvt2w * Vbseff;
        if (T0 >= -0.5) begin
            T1 = 1.0 + T0;
            T2 = dvt2w;
        end else begin
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4;
            T2 = dvt2w * T4 * T4;
        end

        ltw = factor1 * T3 * T1;

        T0 = dvt1 * leff / lt1;
        Theta0 = expoexpm1(T0);

        thetavth = dvt0 * Theta0;
        Delt_vth = thetavth * V0;

        T0 = dvt1w * weff * leff / ltw;
        T5 = expoexpm1(T0);

        T0 = dvt0w * T5;
        T2 = T0 * V0;

        TempRatio = $temperature / tnom - 1.0;
        T0 = sqrt(1.0 + lpe0 / leff);
        T1 = k1ox * (T0 - 1.0) * sqrtPhi + TempRatio * (
            kt1 + kt1l / leff + kt2 * Vbseff);
        Vth_NarrowW = toxe * phi / (weff + W0);

        T3 = eta0 + etab * Vbseff;
        if (T3 < 1.0e-4) begin
            T9 = 1.0 / (3.0 - 2.0 * T3);
            T3 = (2.0e-4 - T3) * T9;
        end

        DIBL_sft = T3 * theta0vb0 * Vds;
        Lpe_Vb = sqrt(1.0 + lpeb / leff);

        Vth = TYPE * vth0 + Lpe_Vb * (k1ox * sqrtPhis - k1 * sqrtPhi) -
            k2ox * Vbseff - Delt_vth - T2 + Vth_NarrowW * (k3 + k3b * Vbseff) +
            T1 - DIBL_sft;

        tmp1 = epssub / Xdep;
        nstar = vtm / `Charge_q * (coxe + tmp1 + cit);
        tmp2 = nfactor * tmp1; // b4temp.c:2336:
        tmp3 = cdsc + cdscb * Vbseff + cdscd * Vds;
        tmp4 = (tmp2 + tmp3 * Theta0 + cit) / coxe;
        if (tmp4 >= -0.5)
            n = 1.0 + tmp4;
        else begin
            T0 = 1.0 / (3.0 + 8.0 * tmp4);
            n = (1.0 + 3.0 * tmp4) * T0;
        end

        // Vth correction for Pocket implant
        if (dvtp0 > 0.0) begin
            T0 = -dvtp1 * Vds;
            T2 = expclamplow(T0);
            T3 = leff + dvtp0 * (1.0 + T2);
            if (TEMPMOD < 2)
                T4 = vtm * ln(leff/T3);
            else
                T4 = Vtm0 * ln(leff/T3);
            Vth = Vth - n * T4;
        end

        // 4.7 DITS_SFT2
        if (dvtp4 == 0.0 || dvtp2factor == 0.0) begin
            T0 = 0.0;
            DITS_Sft2 = 0.0;
        end else begin
            T1 = 2.0 * dvtp4 * Vds;
            T0 = lexp(T1);
            DITS_Sft2 = dvtp2factor * (T0-1)/(T0+1);
            Vth = Vth - DITS_Sft2;
        end
        von = Vth;

        // Poly Gate Si Depletion Effect
        T0 = vfb + phi;
        if (MTRLMOD == 0)
            T1 = `EPSSI;
        else
            T1 = EPSRGATE * `EPS0;

        vgs_eff = BSIM4polyDepletion(T0, ngate, T1, coxe, vgs);
        vgd_eff = BSIM4polyDepletion(T0, ngate, T1, coxe, vgd);

        if (sigvds >= 0.0)
            Vgs_eff = vgs_eff;
        else
            Vgs_eff = vgd_eff;

        Vgst = Vgs_eff - Vth;

        // Calculate Vgsteff
        T0 = n * vtm;
        T1 = mstar * Vgst;
        T10 = exp_branches(T1, T0);

        T1 = voffcbn - (1.0 - mstar) * Vgst;
        T2 = T1 / T0;
        T9 = mstar + n * coxe / cdep0 * expclamp(T2);

        Vgsteff = T10 / T9;

        // Caclulate Effective Channel Geometry
        T9 = sqrtPhis - sqrtPhi;
        Weff = weff - 2.0 * (dwg * Vgsteff + dwb * T9);

        if (Weff < 2e-8) begin
            // to avoid the discontinuity problem due to Weff
            T0 = 1.0 / (6.0e-8 - 2.0 * Weff);
            Weff = 2e-8 * (4.0e-8 - Weff) * T0;
        end

        if (RDSMOD == 1)
            Rds = 0.0;
        else begin
            T0 = 1.0 + prwg * Vgsteff;
            T1 = prwb * T9;

            T2 = 1.0 / T0 + T1;
            T3 = T2 + sqrt(T2 * T2 + 0.01); // 0.01 = 4.0 * 0.05 * 0.05

            T4 = rds0 * 0.5;
            Rds = rdswmin + T3 * T4;

            if (Rds > 0.0)
                grdsw = 1.0 / Rds * NF; /*4.6.2*/
            else
                grdsw = 0.0;
        end

        // Calculate Abulk
        T9 = 0.5 * k1ox * Lpe_Vb / sqrtPhis;
        T1 = T9 + k2ox - k3b * Vth_NarrowW;
        T9 = sqrt(xj * Xdep);
        tmp1 = leff + 2.0 * T9;
        T5 = leff / tmp1;
        tmp2 = A0 * T5;
        tmp3 = weff + B1;
        tmp4 = B0 / tmp3;
        T2 = tmp2 + tmp4;
        T6 = T5 * T5;
        T7 = T5 * T6;

        Abulk0 = 1.0 + T1 * T2;
        T8 = ags * a0 * T7;
        Abulk = Abulk0 - T1 * T8 * Vgsteff;

        if (Abulk0 < 0.1) begin
            T9 = 1.0 / (3.0 - 20.0 * Abulk0);
            Abulk0 = (0.2 - Abulk0) * T9;
        end

        if (Abulk < 0.1) begin
            T9 = 1.0 / (3.0 - 20.0 * Abulk);
            Abulk = (0.2 - Abulk) * T9;
        end

        T2 = keta * Vbseff;
        if (T2 >= -0.9)
            T0 = 1.0 / (1.0 + T2);
        else
            T0 = (17.0 + 20.0 * T2) / (0.8 + T2);

        Abulk = Abulk * T0;
        Abulk0 = Abulk0 * T0;

        // Mobility calculation
        if (MTRLMOD != 0 && MTRLCOMPATMOD == 0)
            T14 = 2.0 * TYPE * (PHIG - EASUB - 0.5*Eg0 + 0.45);
        else
            T14 = 0.0;

        case (MOBMOD)
            0: begin
                T0 = Vgsteff + Vth + Vth - T14;
                T2 = ua + uc * Vbseff;
                T3 = T0 / toxe;
                T12 = sqrt(Vth * Vth + 0.0001);
                T9 = 1.0/(Vgsteff + 2*T12);
                T10 = T9*toxe;
                T8 = ud * T10 * T10 * Vth;
                T6 = T8 * Vth;
                T5 = T3 * (T2 + ub * T3) + T6;
            end
            1: begin
                T0 = Vgsteff + Vth + Vth - T14;
                T2 = 1.0 + uc * Vbseff;
                T3 = T0 / toxe;
                T4 = T3 * (ua + ub * T3);
                T12 = sqrt(Vth * Vth + 0.0001);
                T9 = 1.0/(Vgsteff + 2*T12);
                T10 = T9*toxe;
                T8 = ud * T10 * T10 * Vth;
                T6 = T8 * Vth;
                T5 = T4 * T2 + T6;
            end
            2: begin
                T0 = (Vgsteff + vtfbphi1) / toxe;
                T1 = exp(eu * ln(T0));
                T2 = ua + uc * Vbseff;
                T12 = sqrt(Vth * Vth + 0.0001);
                T9 = 1.0/(Vgsteff + 2*T12);
                T10 = T9 * toxe;
                T8 = ud * T10 * T10 * Vth;
                T6 = T8 * Vth;
                T5 = T1 * T2 + T6;
            end
            4: begin
                // Synopsys 08/30/2013 add
                T0 = Vgsteff + vtfbphi1 - T14;
                T2 = ua + uc * Vbseff;
                T3 = T0 / toxe;
                T12 = sqrt(vtfbphi1*vtfbphi1 + 0.0001);
                T9 = 1.0/(Vgsteff + 2*T12);
                T10 = T9 * toxe;
                T8 = ud * T10 * T10 * vtfbphi1;
                T6 = T8 * vtfbphi1;
                T5 = T3 * (T2 + ub * T3) + T6;
            end
            5: begin
                // Synopsys 08/30/2013 add
                T0 = Vgsteff + vtfbphi1 - T14;
                T2 = 1.0 + uc * Vbseff;
                T3 = T0 / toxe;
                T4 = T3 * (ua + ub * T3);
                T12 = sqrt(vtfbphi1 * vtfbphi1 + 0.0001);
                T9 = 1.0/(Vgsteff + 2*T12);
                T10 = T9 * toxe;
                T8 = ud * T10 * T10 * vtfbphi1;
                T6 = T8 * vtfbphi1;
                T5 = T4 * T2 + T6;
            end
            6: begin
                // Synopsys 08/30/2013 modify
                T0 = (Vgsteff + vtfbphi1) / toxe;
                T1 = exp(eu * ln(T0));
                dT1_dVg = T1 * eu / T0 / toxe;
                T2 = ua + uc * Vbseff;

                T12 = sqrt(vtfbphi1 * vtfbphi1 + 0.0001);
                T9 = 1.0/(Vgsteff + 2*T12);
                T10 = T9 * toxe;
                T8 = ud * T10 * T10 * vtfbphi1;
                T6 = T8 * vtfbphi1;
                T5 = T1 * T2 + T6;
            end
            default: begin // actually just case 3
                // high K mobility
                T0 = (Vgsteff + vtfbphi1)* 1.0e-8 / toxe/6.0;
                T1 = exp(eu * ln(T0));
                T2 = ua + uc * Vbseff;
                // VgsteffVth for us is both the pparam and model version
                T10 = exp(ucs * ln(0.5 + 0.5 * Vgsteff/VgsteffVth));
                T11 = ud / T10;
                T5 = T1 * T2 + T11;
            end
        endcase

        if (T5 >= -0.8)
            Denomi = 1.0 + T5;
        else begin
            T9 = 1.0 / (7.0 + 10.0 * T5);
            Denomi = (0.6 + T5) * T9;
        end

        ueff = u0temp / Denomi;

        // Saturation Drain Voltage Vdsat
        WVCox = Weff * vsattemp * coxe;
        WVCoxRds = WVCox * Rds;

        Esat = 2.0 * vsattemp / ueff;
        EsatL = Esat * leff;

        if (a1 == 0)
            Lambda = a2;
        else if (a1 > 0.0) begin
            T0 = 1.0 - a2;
            T1 = T0 - a1 * Vgsteff - 0.0001;
            T2 = sqrt(T1 * T1 + 0.0004 * T0);
            Lambda = a2 + T0 - 0.5 * (T1 + T2);
        end else begin
            T1 = a2 + a2 * Vgsteff - 0.0001;
            T2 = sqrt(T1 * T1 + 0.0004 * a2);
            Lambda = 0.5 * (T1 + T2);
        end

        Vgst2Vtm = Vgsteff + 2.0 * vtm; //Vtm in C is just Model->vtm (and is never changed)
        if (Rds == 0.0 && Lambda == 1.0) begin
            T0 = 1.0 / (Abulk * EsatL + Vgst2Vtm);
            T3 = EsatL * Vgst2Vtm;
            Vdsat = T3 * T0;
        end else begin
            T9 = Abulk * WVCoxRds;
            T8 = Abulk * T9;
            T7 = Vgst2Vtm * T9;
            T6 = Vgst2Vtm * WVCoxRds;
            T0 = 2.0 * Abulk * (T9 - 1.0 + 1.0 / Lambda);
            T1 = Vgst2Vtm * (2.0 / Lambda - 1.0) + Abulk * EsatL + 3.0 * T7;
            T2 = Vgst2Vtm * (EsatL + 2.0 * T6);
            T3 = sqrt(T1 * T1 - 2.0 * T0 * T2);
            Vdsat = (T1 - T3) / T0;
        end

        // Calculate Vdseff
        T1 = Vdsat - Vds - delta;
        T2 = sqrt(T1 * T1 + 4.0 * delta * Vdsat);
        T0 = T1 / T2;
        T9 = 2.0 * delta;

        if (T1 >= 0.0)
            Vdseff = Vdsat - 0.5 * (T1 + T2);
        else begin
            T4 = T9 / (T2 - T1);
            T5 = 1.0 - T4;
            Vdseff = Vdsat * T5;
        end

        // Original C code has this to short circuit the derivatives,
        // but we just change the below to >=, which makes julia more
        // type stable. TODO: Re-evaluate this.
        // if (Vds == 0.0)
        //    Vdseff = 0.0;

        if (Vdseff >= Vds)
            Vdseff = Vds;

        diffVds = Vds - Vdseff;

        // Velocity Overshoot
        if ($param_given(LAMBDA) && lambda > 0.0) begin
            T1 = leff * ueff;
            T2 = lambda / T1;
            T3 = -T2 / T1 * leff;
            T5 = 1.0 / (Esat * litl);
            T4 = -T5 / EsatL;
            T6 = 1.0 + diffVds * T5;
            T7 = 2.0 / (T6 * T6 + 1.0);
            T8 = 1.0 - T7;
            T10 = 1.0 + T2 * T8;
            EsatL = EsatL * T10;
            Esat = EsatL / leff; // bugfix by Wenwei Yang (4.6.4)
        end

        // Calculate Vasat
        tmp4 = 1.0 - 0.5 * Abulk * Vdsat / Vgst2Vtm;
        T9 = WVCoxRds * Vgsteff;
        T0 = EsatL + Vdsat + 2.0 * T9 * tmp4;
        T9 = WVCoxRds * Abulk;
        T1 = 2.0 / Lambda - 1.0 + T9;
        Vasat = T0 / T1;

        // Calculate Idl first
        tmp1 = vtfbphi2;
        tmp2 = 2.0e8 * toxp;
        T0 = (Vgsteff + tmp1) / tmp2;

        tmp3 = exp(BDOS * 0.7 * ln(T0));
        T1 = 1.0 + tmp3;
        T2 = BDOS * 0.7 * tmp3 / T0;
        Tcen = ADOS * 1.9e-9 / T1;

        Coxeff = epssub * coxp / (epssub + coxp * Tcen);

        CoxeffWovL = Coxeff * Weff / leff;
        beta = ueff * CoxeffWovL;

        AbovVgst2Vtm = Abulk / Vgst2Vtm;
        T0 = 1.0 - 0.5 * Vdseff * AbovVgst2Vtm;
        fgche1 = Vgsteff * T0;
        T9 = Vdseff / EsatL;
        fgche2 = 1.0 + T9;
        gche = beta * fgche1 / fgche2;

        T0 = 1.0 + gche * Rds;
        Idl = gche / T0;

        // Calculate degradation factor due to pocket implant
        // b4ld.c:1837
        if (fprout <= 0.0)
            FP = 1.0;
        else begin
            T9 = fprout * sqrt(leff) / Vgst2Vtm;
            FP = 1.0 / (1.0 + T9);
        end

        // Calculate VACLM
        T8 = pvag / EsatL;
        T9 = T8 * Vgsteff;
        if (T9 > -0.9)
            PvagTerm = 1.0 + T9;
        else begin
            T4 = 1.0 / (17.0 + 20.0 * T9);
            PvagTerm = (0.8 + T9) * T4;
        end

        if (pclm > `MIN_EXP && diffVds > 1e-10) begin
            T0 = 1.0 + Rds * Idl;
            T2 = Vdsat / Esat;
            T1 = Leff + T2;
            Cclm = FP * PvagTerm * T0 * T1 / (pclm * litl);
            VACLM = Cclm * diffVds;
        end else begin
            VACLM = `MAX_EXP + 0.0 * Vdsat * diffVds;
            Cclm = `MAX_EXP + 0.0 * Vdsat * diffVds;
        end

        if (thetaRout > `MIN_EXP) begin
            T8 = Abulk * Vdsat;
            T0 = Vgst2Vtm * T8;
            T1 = Vgst2Vtm + T8;
            T9 = T1 * T1;
            T2 = thetaRout;
            VADIBL = (Vgst2Vtm - T0 / T1) / T2;
            T7 = pdiblb * Vbseff;
            if (T7 >= -0.9) begin
                T3 = 1.0 / (1.0 + T7);
                VADIBL = VADIBL * T3;
            end else begin
                T4 = 1.0 / (0.8 + T7);
                T3 = (17.0 + 20.0 * T7) * T4;
                VADIBL = VADIBL * T3;
            end
            VADIBL = VADIBL * PvagTerm;
        end else
            VADIBL = `MAX_EXP + 0.0 * Vdsat * Vbseff;

        // Calculate Va
        Va = Vasat + VACLM;

        // Calculate VADITS
        T1 = expclamphigh(pditsd * Vds);

        //b4ld.c:1964
        if (pdits > `MIN_EXP) begin
            T2 = 1.0 + PDITSL * Leff;
            VADITS = (1.0 + T2 * T1) / pdits * FP;
        end else
            VADITS = `MAX_EXP;

        // Calculate VASCBE b4ld.c:1977
        if (pscbe2 > 0.0 && pscbe1 >= 0.0) begin // 4.6.2
            if (diffVds > pscbe1 * litl / `EXP_THRESHOLD) begin
                T0 = pscbe1 * litl / diffVds;
                VASCBE = Leff * exp(T0) / pscbe2;
            end else
                VASCBE = `MAX_EXP * Leff / pscbe2 + 0.0 * diffVds;
        end else
            VASCBE = `MAX_EXP + 0.0 * diffVds;

        // Add DIBL to Ids
        T9 = diffVds / VADIBL;
        T0 = 1.0 + T9;
        Idsa = Idl * T0;

        // Add DITS to Ids
        T9 = diffVds / VADITS;
        T0 = 1.0 + T9;
        Idsa = Idsa * T0;

        // Add CLM to Ids
        T0 = ln(Va / Vasat);
        T1 = T0 / Cclm;
        T9 = 1.0 + T1;
        Idsa = Idsa * T9;

        // Substrate current begins
        tmp = alpha0 + alpha1 * Leff;
        if (tmp <= 0.0 || beta0 <= 0.0)
            ISub = 0.0;
        else begin
            T2 = tmp / Leff;
            T1 = T2 * diffVds * expclamplow2(diffVds, beta0);
            T4 = Idsa * Vdseff;
            ISub = T1 * T4;
        end

        csub = ISub;

        // Add SCBE to Ids
        T9 = diffVds / VASCBE;
        T0 = 1.0 + T9;
        Ids = Idsa * T0;
        cdrain = Ids * Vdseff;

        // Source End Velocity Limit
        if ($param_given(VTL) && VTL > 0.0) begin
            T12 = 1.0 / leff / CoxeffWovL;
            T11 = T12 / Vgsteff;
            T10 = -T11 / Vgsteff;
            vs = cdrain * T11; /* vs */
            T0 = 2 * `MM;
            T1 = vs / (vtl * tfactor);
            if (T1 > 0.0) begin
                T2 = 1.0 + exp(T0 * ln(T1));
                T3 = (T2 - 1.0) * T0 / vs;
                Fsevl = 1.0 / exp(ln(T2)/ T0);
            end else
                Fsevl = 1.0 + 0.0 * T0 * T1 * vs;

            cdrain = cdrain * Fsevl;
        end

        IdovVds = Ids;
        if (IdovVds <= IDOVVDSC)
            IdovVds = IDOVVDSC;

        // Calculate Rg
        if (RGATEMOD > 1 || TRNQSMOD != 0 || ACNQSMOD != 0) begin
            $error("TODO");
        end

        // Calculate bias-dependent external S/D resistance
        if (RDSMOD != 0) begin
            // Rs(V)
            T0 = vgs - vfbsd;
            T1 = sqrt(T0 * T0 + 1.0e-4);
            vgs_eff = 0.5 * (T0 + T1);

            T0 = 1.0 + prwg * vgs_eff;
            T1 = -prwb * vbs;

            T2 = 1.0 / T0 + T1;
            T3 = T2 + sqrt(T2 * T2 + 0.01);

            T4 = rs0 * 0.5;
            Rs = rswmin + T3 * T4;
            gstot = sourceConductance / (1.0 + sourceConductance * Rs);

            // Rd(V)
            T0 = vgd - vfbsd;
            T1 = sqrt(T0 * T0 + 1.0e-4);
            vgd_eff = 0.5 * (T0 + T1);
            T0 = 1.0 + prwg * vgd_eff;
            T1 = -prwb * vbd;

            T2 = 1.0 / T0 + T1;
            T3 = T2 + sqrt(T2 * T2 + 0.01);
            T4 = rd0 * 0.5;
            Rd = rdwmin + T3 * T4;
            gdtot = drainConductance / (1.0 + drainConductance * Rd);

            $error("Incompletely implemented");
        end else begin
            gstot  = 0.0;
            gdtot  = 0.0;
        end

        // GIDL / GISL Models
        if (MTRLMOD == 0)
            T0 = 3.0 * toxe;
        else
            T0 = EPSRSUB * toxe / epsrox;

        // Calculate GIDL current
        if (GIDLMOD == 0) begin
            if (MTRLMOD == 0)
                T1 = (vds - vgs_eff - egidl) / T0;
            else
                T1 = (vds - vgs_eff - egidl + vfbsd) / T0;

            if (agidl <= 0 || bgidl <= 0.0 || T1 <= 0.0 || cgidl <= 0.0 || vbd > 0.0) begin
                Igidl = 0.0 * vbd;
            end else begin
                T2 = bgidl / T1;
                Igidl = agidl * weffCJ * lexpclamplow(-T2);
                if (T2 < 100.0)
                    Igidl = Igidl * T1;
                T4 = vbd * vbd;
                T5 = -vbd * T4;
                T6 = cgidl + T5;
                T7 = T5 / T6;
                T8 = 3.0 * cgidl * T4 / T6 / T6;
                Igidl = Igidl * T7;
            end

            // Calculate GISL current
            if (MTRLMOD == 0)
                T1 = (-vds - vgd_eff - egisl) / T0;
            else
                T1 = (-vds - vgd_eff - egisl + vfbsd) / T0;

            if (agisl <= 0 || bgisl <= 0.0 || T1 <= 0.0 || cgisl <= 0.0 || vbs > 0.0)
                Igisl = 0.0 * vbs;
            else begin
                T2 = bgisl / T1;
                Igisl = agisl * weffCJ * lexpclamplow(-T2);
                if (T2 < 100.0)
                    Igisl = Igisl * T1;
                T4 = vbs * vbs;
                T5 = -vbs * T4;
                T6 = cgisl + T5;
                T7 = T5 / T6;
                T8 = 3.0 * cgisl * T4 / T6 / T6;
                Igisl = Igisl * T7;
            end
        end else begin
            // v4.7 new Gidl/GISL model

            /* GISL */
            if (MTRLMOD == 0)
                T1 = (-vds - rgisl * vgd_eff - egisl) / T0;
            else
                T1 = (-vds - rgisl * vgd_eff - egisl + vfbsd) / T0;

            if (agisl <= 0 || bgisl <= 0.0 || T1 <= 0.0 || cgisl < 0.0)
                Igisl = 0.0 * T1;
            else begin
                T2 = bgisl / T1;
                Igisl = agisl * weffCJ * lexpclamplow(-T2);
                if (T2 < 100.0)
                    Igisl = Igisl * T1;
                T4 = vbs - fgisl;
                if (T4 > GIDLCLAMP)
                    T4 = GIDLCLAMP;
                if (T4 == 0)
                    T5 = `EXPL_THRESHOLD;
                else
                    T5 = KGISL / T4;
                if (T5 < `EXPL_THRESHOLD)
                    T6 = exp(T5);
                else
                    T6 = `MAX_EXPL;
                Igisl = Igisl * T6;
            end

            /* GIDL */
            if (MTRLMOD == 0)
                T1 = (vds - rgidl * vgs_eff - egidl) / T0;
            else
                T1 = (vds - rgidl * vgs_eff - egidl + vfbsd) / T0;

            if (agidl <= 0 || bgidl <= 0.0 || T1 <= 0.0 || cgidl < 0.0)
                Igidl = 0.0 * T1;
            else begin
                T2 = bgidl / T1;
                Igidl = agidl * weffCJ * lexpclamplow(-T2);
                if (T2 < 100.0)
                    Igidl = Igidl * T1;
                T4 =  vbd - fgidl;
                if (T4 > GIDLCLAMP)
                    T5 = GIDLCLAMP;
                if (T4 == 0)
                    T5 = `EXPL_THRESHOLD;
                else
                    T5 = kgidl / T4;
                if (T5 < `EXPL_THRESHOLD)
                    T6 = exp(T5);
                else
                    T6 = `MAX_EXPL;
                Igidl = Igidl * T6;
            end
        end

        /* Calculate gate tunneling current */
        if (IGCMOD != 0 || IGBMOD != 0) begin
            Vfb = vfbzb;
            V3 = Vfb - Vgs_eff + Vbseff - `DELTA_3;
            T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3 * abs(Vfb));
            T1 = 0.5 * (1.0 + V3 / T0);
            Vfbeff = Vfb - 0.5 * (V3 + T0);
            Voxacc = Vfb - Vfbeff;
            if (Voxacc < 0.0)
                Voxacc = 0.0;

            T0 = 0.5 * k1ox;
            T3 = Vgs_eff - Vfbeff - Vbseff - Vgsteff;
            if (k1ox == 0.0)
                Voxdepinv = 0.0;
            else if (T3 < 0.0)
                Voxdepinv = -T3 / T0;
            else begin
                T1 = sqrt(T0 * T0 + T3);
                T2 = T0 / T1;
                Voxdepinv = k1ox * (T1 - T0);
            end

            Voxdepinv = Voxdepinv + Vgsteff;
        end

        if (TEMPMOD < 2)
            tmp = vtm;
        else // TEMPMOD = {2,3}
            tmp = Vtm0;

        if (IGCMOD != 0) begin
            T0 = tmp * nigc;
            if (IGCMOD == 1) begin
                VxNVt = (Vgs_eff - TYPE * vth0) / T0;
                if (VxNVt > `EXP_THRESHOLD) begin
                    Vaux = Vgs_eff - TYPE * VTH0;
                end
            end else if (IGCMOD == 2) begin
                VxNVt = (Vgs_eff - von) / T0;
                if (VxNVt > `EXP_THRESHOLD) begin
                    Vaux = Vgs_eff - von;
                end
            end

            if (VxNVt < -`EXPL_THRESHOLD)
                Vaux = T0 * ln(1.0 + `MIN_EXP);
            else if (!(VxNVt > `EXP_THRESHOLD))
                Vaux = T0 * ln(1.0 + exp(VxNVt));

            T2 = Vgs_eff * Vaux;
            T11 = Aechvb;
            T12 = Bechvb;
            T3 = aigc * cigc - bigc;
            T4 = bigc * cigc;
            T5 = T12 * (aigc + T3 * Voxdepinv - T4 * Voxdepinv * Voxdepinv);

            T6 = expclamp(T5);

            Igc = T11 * T2 * T6;

            if ($param_given(PIGCD))
                Pigcd = pigcd;
            else begin
                T11 = -Bechvb;
                T12 = Vgsteff + 1.0e-20;
                T13 = T11 / T12 / T12;
                Pigcd = T13 * (1.0 - 0.5 * Vdseff / T12);
            end

            T7 = -Pigcd * Vdseff;
            T8 = T7 * T7 + 2.0e-4;
            T9 = expclamp(T7);

            T0 = T8 * T8;
            T1 = T9 - 1.0 + 1.0e-4;
            T10 = (T1 - T7) / T8;
            Igcs = Igc * T10;

            T1 = T9 - 1.0 - 1.0e-4;
            T10 = (T7 * T9 - T1) / T8;
            Igcd = Igc * T10;

            T0 = vgs - (vfbsd + VFBSDOFF);
            vgs_eff = sqrt(T0 * T0 + 1.0e-4);

            T2 = vgs * vgs_eff;
            T11 = AechvbEdgeS;
            T12 = BechvbEdge;

            T3 = aigs * cigs - bigs;
            T4 = bigs * cigs;
            T5 = T12 * (aigs + T3 * vgs_eff - T4 * vgs_eff * vgs_eff);
            T6 = expclamp(T5);

            Igs = T11 * T2 * T6;

            T0 = vgd - (vfbsd + vfbsdoff);
            vgd_eff = sqrt(T0 * T0 + 1.0e-4);
            T2 = vgd * vgd_eff;
            T11 = AechvbEdgeD;
            T3 = aigd * cigd - bigd;
            T4 = bigd * cigd;
            T5 = T12 * (aigd + T3 * vgd_eff - T4 * vgd_eff * vgd_eff);
            T6 = expclamp(T5);
            Igd = T11 * T2 * T6;
        end else begin
            Igcs = 0.0;
            Igcd = 0.0;
            Igs = 0.0;
            Igd = 0.0;
        end

        if (IGBMOD != 0) begin
            T0 = tmp * nigbacc;
            T1 = -Vgs_eff + Vbseff + Vfb;
            Vaux = exp_branches(T1, T0);

            T2 = (Vgs_eff - Vbseff) * Vaux;
            T11 = 4.97232e-7 * weff * leff * ToxRatio;
            T12 = -7.45669e11 * toxe;
            T3 = aigbacc * cigbacc - bigbacc;
            T4 = bigbacc * cigbacc;
            T5 = T12 * (aigbacc + T3 * Voxacc - T4 * Voxacc * Voxacc);
            T6 = expclamp(T5);
            Igbacc = T11 * T2 * T6;

            T0 = tmp * nigbinv;
            T1 = Voxdepinv - eigbinv;
            Vaux = exp_branches(T1, T0);

            T2 = (Vgs_eff - Vbseff) * Vaux;
            T11 = T11 * 0.75610;
            T12 = T12 * 1.31724;
            T3 = aigbinv * cigbinv - bigbinv;
            T4 = bigbinv * cigbinv;
            T5 = T12 * (aigbinv + T3 * Voxdepinv - T4 * Voxdepinv * Voxdepinv);
            T6 = expclamp(T5);
            Igbinv = T11 * T2 * T6;
            Igb = Igbinv + Igbacc;
        end else
            Igb = 0.0;

        if (NF != 1.0) begin
            cdrain = cdrain * NF;
            csub = csub * NF;
            Igidl = Igidl * NF;
            Igisl = Igisl * NF;
            Igcs = Igcs * NF;
            Igcd = Igcd * NF;
            Igs = Igs * NF;
            Igd = Igd * NF;
            Igb = Igb * NF;
        end

        // Calculations for noise analysis
        if (TNOIMOD == 0) begin
            Abulk = Abulk0 * abulkCVfactor;
            Vdsat = Vgsteff / Abulk;
            T0 = Vdsat - Vds - `DELTA_4;
            T1 = sqrt(T0 * T0 + 4.0 * `DELTA_4 * Vdsat);
            if (T0 >= 0.0)
                Vdseff = Vdsat - 0.5 * (T0 + T1);
            else begin
                T3 = (`DELTA_4 + `DELTA_4) / (T1 - T0);
                T4 = 1.0 - T3;
                T5 = Vdsat * T3 / (T1 - T0);
                Vdseff = Vdsat * T4;
            end
            if (Vds == 0.0)
                Vdseff = 0.0;

            T0 = Abulk * Vdseff;
            T1 = 12.0 * (Vgsteff - 0.5 * T0 + 1.0e-20);
            T2 = Vdseff / T1;
            T3 = T0 * T2;
            qinv = Coxeff * weffCV * NF
                * leffCV
                * (Vgsteff - 0.5 * T0 + Abulk * T3);
        end else if (TNOIMOD == 2) begin
            noiGd0 = NF * beta * Vgsteff / (1.0 + gche * Rds);
        end

        // BSIM4 C-V begins
        if (XPART < 0) begin
            qgate = 0.0;
            qdrn = 0.0;
            qsrc = 0.0;
            qbulk = 0.0;
        end else begin
            if (CAPMOD == 0) begin
                if (Vbseff < 0.0)
                    VbseffCV = Vbs; // 4.6.2
                else
                    VbseffCV = phi - Phis;

                Vfb = vfbcv;
                Vth = Vfb + phi + k1ox * sqrtPhis;
                Vgst = Vgs_eff - Vth;

                CoxWL = coxe * weffCV * leffCV * NF;
                Arg1 = Vgs_eff - VbseffCV - Vfb;

                if (Arg1 <= 0.0) begin
                    qgate = CoxWL * Arg1;
                    qbulk = -qgate;
                    qdrn = 0.0;
                end else if (Vgst <= 0.0) begin
                    T1 = 0.5 * k1ox;
                    T2 = sqrt(T1 * T1 + Arg1);
                    qgate = CoxWL * k1ox * (T2 - T1);
                    qbulk = -qgate;
                    qdrn = 0.0;

                    T0 = CoxWL * T1 / T2;
                end else begin
                    AbulkCV = Abluk0 * abulkCVfactor;
                    Vdsat = Vgst / AbulkCV;

                    if (XPART > 0.5) begin
                        // 0/100 Charge partition model
                        if (Vdsat <= Vds) begin
                            // Saturation region
                            T1 = Vdsat / 3.0;
                            qgate = CoxWL * (Vgs_eff - Vfb - phi - T1);
                            T2 = - 2.0 / 3.0 * CoxWL * Vgst;
                            qbulk = - (qgate + T2);
                            qdrn = 0.0;
                        end else begin
                            // Linear region
                            Alphaz = Vgst / Vdsat;
                            T1 = 2.0 * Vdsat - Vds;
                            T2 = Vds / (3.0 * T1);
                            T3 = T2 * Vds;
                            T9 = 0.25 * CoxWL;
                            T4 = T9 * Alphaz;
                            T7 = 2.0 * Vds - T1 - 3.0 * T3;
                            T8 = T3 - T1 - 2.0 * Vds;
                            qgate = CoxWL * (Vgs_eff - Vfb - phi - 0.5 * (Vds - T3));
                            T10 = T4 * T8;
                            qdrn = T4 * T7;
                            qbulk = -(qgate + qdrn + T10);
                        end
                    end else if (XPART < 0.5) begin
                        // 40/60 Charge partition model
                        if (Vds >= Vdsat) begin
                            // Saturation region
                            T1 = Vdsat / 3.0;
                            qgate = CoxWL * (Vgs_eff - Vfb - phi - T1);
                            T2 = - 2.0 / 3.0 * CoxWL * Vgst;
                            qdrn = 0.4 * T2;
                        end else begin
                            // Linear region
                            Alphaz = Vgst / Vdsat;
                            T1 = 2.0 * Vdsat - Vds;
                            T2 = Vds / (3.0 * T1);
                            T3 = T2 * Vds;
                            T9 = 0.25 * CoxWL;
                            T4 = T9 * Alphaz;
                            qgate = CoxWL * (Vgs_eff - Vfb - phi - 0.5 * (Vds - T3));
                            T5 = T3 / T1;
                            T6 = 8.0 * Vdsat * Vdsat - 6.0 * Vdsat * Vds + 1.2 * Vds * Vds;
                            T8 = T2/T1;
                            T7 = Vds - T1 - T8 * T6;
                            qdrn = T4 * T7;
                            T7 = 2.0 * (T1 + T3);
                            qbulk = -(qgate - T4 * T7);
                        end
                    end else begin
                        // 50/50 partitioning
                        if (Vds >= Vdsat) begin
                            // Saturation region
                            T1 = Vdsat / 3.0;
                            qgate = CoxWL * (Vgs_eff - Vfb - phi - T1);
                            T2 = - 2.0 / 3.0 * CoxWL * Vgst;
                            qbulk = -(qgate + T2);
                            qdrn = 0.5 * T2;
                        end else begin
                            // Linear region
                            Alphaz = Vgst / Vdsat;
                            T1 = 2.0 * Vdsat - Vds;
                            T2 = Vds / (3.0 * T1);
                            T3 = T2 * Vds;
                            T9 = 0.25 * CoxWL;
                            T4 = T9 * Alphaz;
                            qgate = CoxWL * (Vgs_eff - Vfb - phi - 0.5 * (Vds - T3));
                            T7 = T1 + T3;
                            qdrn = -T4 * T7;
                            qbulk = - (qgate + qdrn + qdrn);
                        end
                    end
                end
            end else begin // CAPMOD != 0
                if (Vbseff < 0.0)
                    VbseffCV = Vbseff;
                else
                    VbseffCV = phi - Phis;

                CoxWL = coxe * weffCV * leffCV * NF;

                if (CVCHARGEMOD == 0) begin
                    T0 = vtm * n * noff;

                    Vgsteff = exp_branches(Vgst - VOFFCV, T0);
                end else begin
                    T0 = n * vtm;
                    T1 = mstarcv * Vgst;
                    T10 = exp_branches(T1, T0);

                    T1 = (1.0 - mstarcv) * Vgst;
                    VOFFCBNCV = T1;
                    T9 = mstarcv + n * expclamp(T1/T0) * coxe / cdep0;

                    Vgsteff = T10/T9;
                end

                if (CAPMOD == 1) begin
                    Vfb = vfbzb;
                    V3 = Vfb - Vgs_eff + VbseffCV - `DELTA_3;
                    T0 = sqrt(V3*V3 + 4.0 * `DELTA_3 * abs(Vfb));
                    T1 = 0.5 * (1.0 + V3 / T0);
                    Vfbeff = Vfb - 0.5 * (V3 + T0);
                    Qac0 = CoxWL * (Vfbeff - Vfb);

                    T0 = 0.5 * k1ox;
                    T3 = Vgs_eff - Vfbeff - VbseffCV - Vgsteff;
                    if (k1ox == 0.0) begin
                        T1 = 0.0;
                        T2 = 0.0;
                    end else if (T3 < 0.0) begin
                        T1 = T0 + T3 / k1ox;
                        T2 = CoxWL;
                    end else begin
                        T1 = sqrt(T0 * T0 + T3);
                        T2 = CoxWL * T0 / T1;
                    end

                    Qsub0 = CoxWL * k1ox * (T1 - T0);
                    AbulkCV = Abulk0 * abulkCVfactor;
                    VdsatCV = Vgsteff / AbulkCV;

                    T0 = VdsatCV - Vds - `DELTA_4;
                    T1 = sqrt(T0 * T0 + 4.0 * `DELTA_4 * VdsatCV);
                    if (T0 >= 0.0)
                        VdseffCV = VdsatCV - 0.5 * (T0 + T1);
                    else begin
                        T3 = (`DELTA_4 + `DELTA_4) / (T1 - T0);
                        T4 = 1.0 - T3;
                        T5 = VdsatCV * T3 / (T1 - T0);
                        VdseffCV = VdsatCV * T4;
                    end

                    if (Vds == 0.0) begin
                        VdseffCV = 0.0;
                    end

                    T0 = AbulkCV * VdseffCV;
                    T1 = 12.0 * (Vgsteff - 0.5 * T0 + 1.0e-20);
                    T2 = VdseffCV / T1;
                    T3 = T0 * T2;

                    qgate = CoxWL * (Vgsteff - 0.5 * VdseffCV + T3);

                    T7 = 1.0 - AbulkCV;
                    qbulk = CoxWL * T7 * (0.5 * VdseffCV - T3);

                    if (XPART > 0.5) begin
                        // 0/100 Charge petition model
                        T1 = T1 + T1;
                        qsrc = -CoxWL * (0.5 * Vgsteff + 0.25 * T0 - T0 * T0 / T1);
                    end else if (XPART < 0.5) begin
                        // 40/60 Charge petition model
                        T1 = T1 / 12.0;
                        T2 = 0.5 * CoxWL / (T1 * T1);
                        T3 = Vgsteff * (2.0 * T0 * T0 / 3.0 + Vgsteff * (Vgsteff - 4.0 * T0 / 3.0)) - 2.0 * T0 * T0 * T0 / 15.0;
                        qsrc = -T2 * T3;
                    end else begin
                        // 50/50 Charge petition model
                        qsrc = -0.5 * (qgate + qbulk);
                    end

                    qgate = qgate + Qac0 + Qsub0;
                    qbulk = qbulk - (Qac0 + Qsub0);
                    qdrn = -(qgate + qbulk + qsrc);
                end else if (CAPMOD == 2) begin
                    V3 = vfbzb - Vgs_eff + VbseffCV - `DELTA_3;
                    T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3 * abs(vfbzb));
                    T1 = 0.5 * (1.0 + V3 / T0);
                    Vfbeff = vfbzb - 0.5 * (V3 + T0);
                    Cox = coxp;
                    Tox = 1.0e8 * toxp;
                    T0 = (Vgs_eff - VbseffCV - vfbzb) / Tox;
                    tmp = T0 * acde;
                    Tcen = ldeb * expclamp(tmp);
                    LINK = 1.0e-3 * toxp;
                    V3 = ldeb - Tcen - LINK;
                    V4 = sqrt(V3 * V3 + 4.0 * LINK * ldeb);
                    Tcen = ldeb - 0.5 * (V3 + V4);
                    T1 = 0.5 * (1.0 + V3 / V4);
                    Ccen = epssub / Tcen;
                    T2 = Cox / (Cox + Ccen);
                    Coxeff = T2 * Ccen;
                    CoxWLcen = CoxWL * Coxeff / coxe;
                    Qac0 = CoxWLcen * (Vfbeff - vfbzb);

                    T0 = 0.5 * k1ox;
                    T3 = Vgs_eff - Vfbeff - VbseffCV - Vgsteff;
                    if (k1ox == 0.0) begin
                        T1 = 0.0;
                        T2 = 0.0;
                    end else if (T3 < 0.0) begin
                        T1 = T0 + T3 / k1ox;
                        T2 = CoxWLcen;
                    end else begin
                        T1 = sqrt(T0 * T0 + T3);
                        T2 = CoxWLcen * T0 / T1;
                    end

                    Qsub0 = CoxWLcen * k1ox * (T1 - T0);

                    // Gate-bias dependent delta Phis begins
                    if (k1ox <= 0.0) begin
                        Denomi = 0.25 * moin * vtm;
                        T0 = 0.5 * sqrtPhi;
                    end else begin
                        Denomi = moin * vtm * k1ox * k1ox;
                        T0 = k1ox * sqrtPhi;
                    end
                    T1 = 2.0 * T0 + Vgsteff;

                    DeltaPhi = vtm * ln(1.0 + T1 * Vgsteff / Denomi);
                    T0 = Vgsteff - DeltaPhi - 0.001;
                    T1 = sqrt(T0 * T0 + Vgsteff * 0.004);
                    VgDP = 0.5 * (T0 + T1);

                    Tox = Tox + Tox;
                    T0 = (Vgsteff + vtfbphi2) / Tox;
                    tmp = exp(BDOS * 0.7 * ln(T0));
                    T1 = 1.0 + tmp;
                    T2 = BDOS * 0.7 * tmp / (T0 * Tox);
                    Tcen = ADOS * 1.9e-9 / T1;

                    Ccen = epssub / Tcen;
                    T0 = Cox / (Cox + Ccen);
                    Coxeff = T0 * Ccen;
                    CoxWLcen = CoxWL * Coxeff / coxe;

                    AbulkCV = Abulk0 * abulkCVfactor;
                    VdsatCV = VgDP / AbulkCV;
                    T0 = VdsatCV - Vds - `DELTA_4;
                    T1 = sqrt(T0 * T0 + 4.0 * `DELTA_4 * VdsatCV);
                    if (T0 >= 0.0)
                        VdseffCV = VdsatCV - 0.5 * (T0 + T1);
                    else begin
                        T3 = (`DELTA_4 + `DELTA_4) / (T1 - T0);
                        T4 = 1.0 - T3;
                        T5 = VdsatCV * T3 / (T1 - T0);
                        VdseffCV = VdsatCV * T4;
                    end

                    if (Vds == 0.0)
                        VdseffCV = 0.0;

                    T0 = AbulkCV * VdseffCV;
                    T1 = VgDP;
                    T2 = 12.0 * (T1 - 0.5 * T0 + 1.0e-20);
                    T3 = T0 / T2;
                    T4 = 1.0 - 12.0 * T3 * T3;
                    T5 = AbulkCV * (6.0 * T0 *(4.0 * T1 - T0) / (T2 * T2) - 0.5);
                    T6 = T5 * VdseffCV / AbulkCV;

                    qgate = CoxWLcen * (T1 - T0 * (0.5 - T3));

                    T7 = 1.0 - AbulkCV;

                    qbulk = CoxWLcen * T7 * (0.5 * VdseffCV - T0 * VdseffCV / T2);

                    if (XPART > 0.5)
                        qsrc = -CoxWLcen * (T1 / 2.0 + T0 / 4.0 - 0.5 * T0 * T0 / T2);
                    else if (XPART < 0.5) begin
                        T2 = T2 / 12.0;
                        T3 = 0.5 * CoxWLcen / (T2 * T2);
                        T4 = T1 * (2.0 * T0 * T0 / 3.0 + T1 * (T1 - 4.0 * T0 / 3.0)) - 2.0 * T0 * T0 * T0 / 15.0;
                        qsrc = -T3 * T4;
                    end else
                        qsrc = -0.5 * qgate;

                    qgate = qgate + Qac0 + Qsub0 - qbulk;
                    qbulk = qbulk - (Qac0 + Qsub0);
                    qdrn = -(qgate + qbulk + qsrc);
                end
            end

            if (TRNQSMOD == 1 || ACNQSMOD == 1) begin
                qcheq = -(qbulk + qgate);
            end
        end

// finished:
        czbd = DunitAreaTempJctCap * ADeff;
        czbs = SunitAreaTempJctCap * ASeff;
        czbdsw = DunitLengthSidewallTempJctCap * PDeff;
        czbdswg = DunitLengthGateSidewallTempJctCap * weffCJ * NF;
        czbssw = SunitLengthSidewallTempJctCap * PSeff;
        czbsswg = SunitLengthGateSidewallTempJctCap
                * weffCJ * NF;

        if (vbs_jct < 0.0) begin
            qbs = qbsd_calc(vbs_jct, czbs, PhiBS, MJS);
            qbs = qbs + qbsd_calc(vbs_jct, czbssw, PhiBSWS, MJSWS);
            qbs = qbs + qbsd_calc(vbs_jct, czbsswg, PhiBSWGS, MJSWGS);
        end else begin
            T0 = czbs + czbssw + czbsswg;
            T1 = vbs_jct * (czbs * MJS / PhiBS +
                            czbssw * MJSWS / PhiBSWS +
                            czbsswg * MJSWGS / PhiBSWGS);
            qbs = vbs_jct * (T0 + 0.5 * T1);
        end

        if (vbd_jct < 0.0) begin
            qbd = qbsd_calc(vbd_jct, czbd, PhiBD, MJD);
            qbd = qbd + qbsd_calc(vbd_jct, czbdsw, PhiBSWD, MJSWD);
            qbd = qbd + qbsd_calc(vbd_jct, czbdswg, PhiBSWGD, MJSWGD);
        end else begin
            T0 = czbd + czbdsw + czbdswg;
            T1 = vbd_jct * (czbd * MJD / PhiBD +
                            czbdsw * MJSWD / PhiBSWD +
                            czbdswg * MJSWGD / PhiBSWGD);
            qbd = vbd_jct * (T0 + 0.5*T1);
        end

        // Bunch of convergence stuff here we don't need

        if (RGATEMOD == 3) begin
            vgdx = vgmd;
            vgsx = vgms;
        end else begin
            // For rgateMod == 0, 1 and 2
            vgdx = vgd;
            vgsx = vgs;
        end

        if (CAPMOD == 0) begin
            qgdo = cgdo * vgdx;
            qgso = cgso * vgsx;
        end else begin
            // For both capMod == 1 and 2
            T0 = vgdx + `DELTA_1;
            T1 = sqrt(T0 * T0 + 4.0 * `DELTA_1);
            T2 = 0.5 * (T0 - T1);

            T3 = weffCV * cgdl;
            T4 = sqrt(1.0 - 4.0 * T2 / ckappad);
            qgdo = (cgdo + T3) * vgdx - T3 * (T2 + 0.5 * ckappad * (T4 - 1.0));

            T0 = vgsx + `DELTA_1;
            T1 = sqrt(T0 * T0 + 4.0 * `DELTA_1);
            T2 = 0.5 * (T0 - T1);
            T3 = weffCV * cgsl;
            T4 = sqrt(1.0 - 4.0 * T2 / ckappas);
            qgso = (cgso + T3) * vgsx - T3 * (T2 + 0.5 * ckappas * (T4 - 1.0));
        end

        if (NF != 1.0) begin
            qgdo = qgdo * NF;
            qgso = qgso * NF;
        end

// line755:
        if (sigvds >= 0.0) begin
            if (TRNQSMOD == 0) begin
                qdrn = qdrn - qgdo;
                //TODO omegas ???
                if (RGATEMOD == 3) begin
                    qgmb = cgbo * vgmb;
                    qgmid = qgdo + qgso + qgmb;
                    qbulk = qbulk - qgmb;
                    qsrc = -(qgate + qgmid + qbulk + qdrn);
                end else begin
                    qgb = cgbo * vgb;
                    qgate = qgate + qgdo + qgso + qgb;
                    qbulk = qbulk - qgb;
                    qsrc = -(qgate + qbulk + qdrn);
                end
            end else begin
                if (RGATEMOD == 3) begin
                    qgmb = cgbo * vgmb;
                    qgmid = qgdo + qgso + qgmb;
                    qgate = 0.0;
                    qbulk = -qgmb;
                    qdrn = -qgdo;
                    qsrc = -(qgmid + qbulk + qdrn);
                end else begin
                    qgb = cgbo * vgb;
                    qgate = qgdo + qgso + qgb;
                    qbulk = -qgb;
                    qdrn = -qgdo;
                    qsrc = -(qgate + qbulk + qdrn);
                end
            end
        end else begin
            if (TRNQSMOD == 0) begin
                qsrc = qdrn - qgso;
                if (RGATEMOD == 3) begin
                    qgmb = cgbo * vgmb;
                    qgmid = qgdo + qgso + qgmb;
                    qbulk = qbulk - qgmb;
                    qdrn = -(qgate + qgmid + qbulk + qsrc);
                end else begin
                    qgb = cgbo * vgb;
                    qgate = qgate + qgdo + qgso + qgb;
                    qbulk = qbulk - qgb;
                    qdrn = -(qgate + qbulk + qsrc);
                end
            end else begin
                qcheq = qcheqs;
                if (RGATEMOD == 3) begin
                    qgmb = cgbo * vgmb;
                    qgmid = qgdo + qgso + qgmb;
                    qgate = 0.0;
                    qbulk = -qgmb;
                    qdrn = -qgdo;
                    qsrc = -qgso;
                end else begin
                    qgb = cgbo * vgb;
                    qgate = qgdo + qgso + qgb;
                    qbulk = -qgb;
                    qdrn = -qgdo;
                    qsrc = -qgso;
                end
            end
        end

        if (TRNQSMOD != 0)
            qcdump = qdef * `SCALINGFACTOR;

        qg = qgate;
        qd = qdrn - qbd;
        qs = qsrc - qbs;
        if (RBODYMOD == 0)
            qb = qbulk + qbd + qbs;
        else
            qb = qbulk;

// line860:
        // N.B.: This is confusing, but the NIintegrate calls in SPICE models
        // actuall compute derivatives from our perspective.
        cqgate = ddt(qg);
        cqbody = ddt(qb); // cqb
        cqdrn = ddt(qd);

        // SPICE's scheme is not super easy to understand, but essentially,
        // these are all non-linear capacitances. What SPICE really wants to do
        // here is make the charges a state and add the two equations:
        //
        //   q = f(V)
        //   dq/dt = I
        //   I = < The rest of the circuit >
        //
        // It then does a non-linear solve for `V` and computes an approximation
        // for dq/dt(V) as:
        //
        //   dq/dt(V) = 1/Δ [f(V) - f(V(t-Δt))
        //
        // Where f(V(t-Δt)) is remembered from the last timestep and `V` is V(t).
        // However, the  solver does not explicitly linearize the objective,
        // so SPICE does that here manually computing:
        //
        //   ∂(dq/dt)/∂V = 1/Δ ∂f/∂V
        //
        // And then attempting the linear solve of:
        //
        //  dq/dt(Vⁿ⁺¹) = dq/dt(Vⁿ) + ∂(dq/dt)/∂V * (Vⁿ⁺¹ - Vⁿ)
        //
        // Then, remembering that SPICE's non-linear solve formulation is:
        //
        //    A Vⁿ⁺¹ = -RHS
        //
        // We should expect it to add 1/Δ ∂f/∂V to the appropriate entry of `A`
        // and -1/Δ ∂f/∂V Vⁿ to the RHS.
        //
        // However, in Verilog-A notation, all we need to say is that
        // I <+ ddt(q) and we're good to go, leaving the details to the
        // discretization and non-linear solver.

        // Let's do a concrete example, here, then skip the rest, which is
        // similar. In the original `C` code, we have:
        //
        //    NIintegrate(...); // Computes BSIM4cqg from BSIMcqg (using discretization)
        //    [...]
        //    cqgate = *(ckt->CKTstate0 + here->BSIM4cqg);
        //    ceqqg = cqgate - gcggb * vgb + gcgdb * vbd + gcgsb * vbs;
        //
        // Where the `gcggb` are just ddx(qgate, vgb), etc. Later, we see that
        // the `gcggb` are also being added into the matrix at the appropriate
        // entry.

        ceqqg = TYPE * ddt(qg);
        ceqqd = TYPE * ddt(qd); // Includes ceqqjs ceqqjd if applicable
        ceqqb = TYPE * ddt(qb);
        //$strobe(qb);

        if (RBODYMOD != 0) begin
            ceqqjs = TYPE * ddt(qbs);
            ceqqjd = TYPE * ddt(qbd);
        end

        if (RGATEMOD == 3)
            ceqqgmid = ddt(qgmid);
        else
            ceqqgmid = 0.0;

        // [CEDAR] ceqqjs, ceqqjd assignment unnecessary

        if (TRNQSMOD != 0) begin
            // TODO: Is the T0 here actually required or is is part of the
            // linearaization? Let's leave it out for now.
            cqdef = ddt(qcdump);
            cqcheq = ddt(qcheq);
        end

        // Load current vvector
        if (sigvds >= 0) begin
            // [CEDAR] devsign multiplication moved below
            // N.B.: gds = ddx(cdrain, vds), etc. (part of NL linearization)
            ceqdrn = TYPE * cdrain;
            ceqbd = TYPE * (csub + Igidl);
            ceqbs = TYPE * Igisl;

            // I{g,s,b}toteq computation not required. Ig{s,b,cd,cs} are added
            // below as necessary.

            if (RGATEMOD == 2) T0 = vges - vgs;
            else if (RGATEMOD == 3) T0 = vgms - vgs;
            if (RGATEMOD > 1)
                $error("TODO");
            else
                ceqgcrg = 0.0;
        end else begin
            ceqdrn = -TYPE * cdrain;
            ceqbs = TYPE * (csub + Igisl);
            ceqbd = TYPE * Igidl;
        end

        if (RDSMOD == 1) begin
            // N.B.: devsign multiplcation moved below for consistency
            ceqgstot = gstotd * vds + gstotg * vgs + gstotb * vbs;
            ceqgdtot = -(gdtotd * vds + gdtotg * vgs + gdtotb * vbs);
        end

        ceqjs = TYPE * cbs;
        ceqjd = TYPE * cbd;
        // Remaining negations absorbed into devsign multiplications below

        // Easiest way to find out where these currents go is to look at the
        // KCLs loading the RHS and match them.
        // N.B.: On the C side, currents are *subtraced* from the node they flow
        //       from and *added* to the node they flow to.
        I(di, si) <+ ceqdrn + ceqqd;
        I(si, bi) <+ ceqbs;
        I(di, bi) <+ ceqbd;
        I(gi, di) <+ TYPE * (Igd + (sigvds >= 0 ? Igcd : Igcs));
        I(gi, si) <+ ceqqg + TYPE * (Igs + (sigvds >= 0 ? Igcs : Igcd));
        I(gi, bi) <+ TYPE * Igb;

        if (RGATEMOD == 0) begin
            V(g, gm) <+ 0;
            V(gm, gi) <+ 0;
        end else if (RGATEMOD == 1) begin
            V(g, gm) <+ 0;
            I(g, gi) <+ V(g, gi) * grgeltd;
        end else if (RGATEMOD == 2) begin
            V(g, gm) <+ 0;
            I(g, gi) <+ ceqgcrg;
        end else if (RGATEMOD == 3) begin
            I(gm, gi) <+ ceqgcrg;
            I(g, gi) <+ V(g, gi) * grgeltd;
            I(gm, si) <+ ceqqgmid;
        end

        if (RBODYMOD == 0) begin
            I(bi, di) <+ ceqjd;
            I(bi, si) <+ (ceqjs + ceqqb);
            V(bi, b) <+ 0;
            V(db, b) <+ 0;
            V(sb, b) <+ 0;
        end else begin
            I(db, di) <+ ceqjd ;//+ ceqqjd;
            // TODO: This is what the original SPICE model does.
            // Should this be I(di, db) instead?
            I(db, si) <+ ceqqjd;
            I(sb, si) <+ ceqjs + ceqqjs;
            I(bi, si) <+ ceqqb;

            // Resistor network (See Figure 9.3 in the manual)
            I(b , bi) <+ V(b , bi) * grbpb;
            I(sb, bi) <+ V(sb, bi) * grbps;
            I(sb, b ) <+ V(sb, b ) * grbsb;
            I(db, b ) <+ V(db, b ) * grbdb;
            I(db, bi) <+ V(db, bi) * grbpd;
        end

        if (RDSMOD == 0) begin
            gspr = sourceConductance;
            gdpr = drainConductance;
        end else begin
            gspr = 0.0;
            gdpr = 0.0;
        end

        if (RDSMOD == 1) begin
            I(d, di) <+ ceqgdtot;
            I(si, s) <+ ceqgstot;
        end
        if (createDrainNode == 1)
            I(d, di) <+ gdpr * V(d, di);
        if (createSourceNode == 1)
            I(s, si) <+ gspr * V(s, si);

        if (TRNQSMOD == 1)
            I(q) <+ cqcheq - cqdef;
        else
            V(q) <+ 0;

        // Observables and noise
        //gmgs = ddx(cdrain, V(gi));
        //gmbs = ddx(cdrain, V(bi));
        //gds = ddx(cdrain, V(di));

        // Noise model
        if (TNOIMOD == 0) begin
            if (RDSMOD == 0) begin
                gspr = sourceConductance;
                gdpr = drainConductance;
                if (grdsw > 0.0)
                    tmp = 1.0 / grdsw;
                else
                    tmp = 0.0;
            end else begin
                gspr = gstot;
                gdpr = gdtot;
                tmp = 0.0;
            end
        end else if (TNOIMOD == 1) begin
            T5 = Vgsteff / EsatL;
            T5 = T5 * T5;
            npart_beta = RNOIA * (1.0 + T5 * TNOIA * leff);
            npart_theta = RNOIB * (1.0 + T5 * TNOIB * leff);

            if (npart_theta > 0.9)
                npart_theta = 0.9;

            if (npart_theta > 0.9 * npart_beta)
                npart_theta = 0.9 * npart_beta;

            if (RDSMOD == 0) begin
                gspr = sourceConductance;
                gdpr = drainConductance;
            end else begin
                gspr = gstot;
                gdpr = gdtot;
            end

            if (VERSION < 4.6) begin
                if (sigvds >= 0.0)
                    gspr = gspr / (1.0 + npart_theta * npart_theta * gspr / IdovVds);
                else
                    gdpr = gdpr / (1.0 + npart_theta * npart_theta * gdpr / IdovVds);
            end else begin
                if (sigvds >= 0.0)
                    gspr = gspr * (1.0 + npart_theta * npart_theta * gspr / IdovVds);
                else
                    gdpr = gdpr * (1.0 + npart_theta * npart_theta * gdpr / IdovVds);
            end
        end else begin
            // TNOIMOD == 2 (v4.7)
            if (RDSMOD == 0) begin
                gspr = sourceConductance;
                gdpr = drainConductance;
            end else begin
                gspr = gstot;
                gdpr = gdtot;
            end
        end

        `define thermal_noise(cond, name) white_noise(4 * `P_K * $temperature * (cond), name)
        if(RDSMOD > 0) begin // we don't support RDS noise for RDSMOD=0
            I(di, d) <+ `thermal_noise(gdpr, "Rd_thermal");
            I(si, s) <+ `thermal_noise(gspr, "Rs_thermal");
        end

        if (RGATEMOD == 1) begin
            I(gi, g) <+ `thermal_noise(grgeltd, "Rg_thermal");
        end else if (RGATEMOD == 2) begin
            T0 = 1.0 + grgeltd / gcrg;
            T1 = T0 * T0;
            I(gi, g) <+ `thermal_noise(grgeltd / T1, "Rg_thermal");
        end else if (RGATEMOD == 3)
            I(gm, g) <+ `thermal_noise(grgeltd, "Rg_thermal");

        if (RBODYMOD != 0) begin
            if (bodymode == 5) begin
                I(bi, sb) <+ `thermal_noise(grbps, "Rbisb_thermal");
                I(bi, db) <+ `thermal_noise(grbpd, "Rbidb_thermal");
                I(bi, b) <+ `thermal_noise(grbpb, "Rbib_thermal");
                I(b, sb) <+ `thermal_noise(grbsb, "Rbsb_thermal");
                I(b, db) <+ `thermal_noise(grbdb, "Rbdb_thermal");
            end else if (bodymode == 3) begin
                I(bi, sb) <+ `thermal_noise(grbps, "Rbisb_thermal");
                I(bi, db) <+ `thermal_noise(grbpd, "Rbidb_thermal");
                I(bi, b) <+ `thermal_noise(grbpb, "Rbib_thermal");
            end else if (bodymode == 1) begin
                I(bi, b) <+ `thermal_noise(grbpb, "Rbib_thermal");
            end
        end

        if (TNOIMOD == 2) begin
            eta = 1.0 - Vdseff * AbovVgst2Vtm;
            T0 = 1.0 - eta;
            T1 = 1.0 + eta;
            T2 = T1 + 2.0 * Abulk * vtm / Vgsteff;
            Lvsat = leff * (1.0 + Vdseff / EsatL);
            T6 = leff / Lvsat;
            gamma = T6 * (0.5 * T1 + T0 * T0 / (6.0 * T2));
            T3 = T2 * T2;
            T4 = T0 * T0;
            T5 = T3 * T3;
            delta = (T1 / T3 - (5.0 * T1 + T2) * T4 / (15.0 * T5) + T4 * T4 / (9.0 * T5 * T2)) / (6.0 * T6 * T6 * T6);
            T7 = T0 / T2;
            epsilon = (T7 - T7 * T7 * T7 / 3.0) / (6.0 * T6);
            T8 = Vgsteff / EsatL;
            T8 = T8 * T8;
            if (VERSION <= 4.80) begin
                npart_c = RNOIC * (1.0 + T8
                            * TNOIC * leff);
                ctnoi = epsilon / sqrt(gamma * delta)
                        * (2.5316 * npart_c);

                npart_beta = RNOIA * (1.0 + T8
                        * TNOIA * leff);
                npart_theta = RNOIB * (1.0 + T8
                        * TNOIB * leff);
                gamma = gamma * (3.0 * npart_beta * npart_beta);
                delta = delta * (3.75 * npart_theta * npart_theta);

                GammaGd0 = gamma * noiGd0;
                C0 = Coxeff * weffCV * NF * leffCV;
                T0 = C0 / noiGd0;
                sigrat = T0 * sqrt(delta / gamma);
            end else begin
                npart_c = RNOIC * (1.0 + T8 * TNOIC * leff);
                // Limits added for rnoia, rnoib, rnoic, tnoia, tnoib and tnoic in BSIM4.8.1
                T9 = gamma * delta;
                if (T9 > 0)
                    ctnoi   = epsilon / sqrt( gamma * delta) * (2.5316 * npart_c);
                else
                    ctnoi   = 1.0 ;
                if (ctnoi > 1)
                    ctnoi=1;
                if (ctnoi < 0)
                    ctnoi=0;

                npart_beta = RNOIA * (1.0 + T8
                                * TNOIA * leff);
                npart_theta = RNOIA * (1.0 + T8
                    * TNOIA * leff);
                gamma = gamma * (3.0 * npart_beta * npart_beta);
                delta = delta * (3.75 * npart_theta * npart_theta);

                GammaGd0 = gamma * noiGd0;
                C0 = Coxeff * weffCV * NF * leffCV;
                T0 = C0 / noiGd0;

                if (gamma > 0 && delta > 0)
                    sigrat = T0 * sqrt(delta / gamma);
                else
                    sigrat = 0.0;
            end
        end

        case (TNOIMOD)
            0: begin
                T0 = ueff * abs(qinv);
                T1 = T0 * tmp + leff * leff;
                I(di, si) <+ `thermal_noise((T0 / T1) * NTNOI, "thermal");
            end
            1: begin
                T0 = gmgs + gmbs + gds;
                T0 = T0 * T0;
                igsquare = npart_theta * npart_theta * T0  / IdovVds;
                T1 = npart_beta * (gmgs + gmbs) + gds;
                T2 = T1 * T1 / IdovVds;
                I(di, si) <+ `thermal_noise(T2 - igsquare, "thermal");
            end
            2: begin
                T2 = GammaGd0;
                T3 = ctnoi * ctnoi;
                T4 = 1.0 - T3;
                I(di, si) <+ T2 * T4;

                omega = 2.0 * `M_PI * $simparam("frequency");
                T5 = omega * sigrat;
                T6 = T5 * T5;
                T7 = T6 / (1.0 + T6);

                $error("TODO: Correlated noise");
            end
        endcase

        case (FNOIMOD)
            0: I(di, si) <+ flicker_noise(exp(AF * ln(max(abs(cdrain), `N_MINLOG))) * leff * leff * coxe, EF, "flicker");
            1: begin
                Ssi = Eval1ovFNoise(Vds, leff, weff, vsattemp, Vdseff, Vgsteff, litl, cdrain, ueff, Abulk, $temperature,
                    coxe, AbovVgst2Vtm, EM, NF, LINTNOI, TNOIA, TNOIB, TNOIC, nstar);
                T10 = NOIA * `P_K * $temperature;
                T11 = weff * NF * leff * 1e10 * nstar * nstar;
                Swi = T10 / T11 * cdrain * cdrain;
                T1 = Swi + Ssi;
                if (T1 > 0.0)
                    I(di, si) <+ flicker_noise(Ssi * Swi / T1, EF, "flicker");
            end
        endcase

        // Shot noise
        `define shot_noise(I, name) white_noise(2 * `P_Q * abs(I), name)
        if (sigvds >= 0) begin
            I(gi, si) <+ `shot_noise(Igs + Igcs, "shot");
            I(gi, di) <+ `shot_noise(Igd + Igcd, "shot");
        end else begin
            I(gi, si) <+ `shot_noise(Igs + Igcd, "shot");
            I(gi, di) <+ `shot_noise(Igd + Igcs, "shot");
        end
        I(gi, bi) <+ `shot_noise(Igb, "shot");

    end
endmodule
